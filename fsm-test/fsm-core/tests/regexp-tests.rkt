#lang racket/base
(module+ tests
  (require "../../../fsm-core/private/regexp.rkt"
           "../../../fsm-core/private/regexp-constructors.rkt"
           "../../../fsm-core/private/constants.rkt"
           rackunit
           )

  ;; singleton-regexp tests
  (check-equal?
   (singleton-regexp-a (singleton-regexp "a"))
   "a")
  (check-equal?
   (singleton-regexp-a (singleton-regexp "A"))
   "A")
  (check-exn
   #rx"Step five of the design recipe for regular expressions has not been successfully completed.
The argument to singleton-regexp must be a single lowercase Roman alphabet string, but found: \"abc\""
   (lambda () (singleton-regexp "abc"))
   )
  (check-exn
   #rx"Step five of the design recipe for regular expressions has not been successfully completed.
The argument to singleton-regexp must be a single lowercase Roman alphabet string, but found: 5"
   (lambda () (singleton-regexp 5))
   )

  (define singleton-a (singleton-regexp "a"))
  (define singleton-b (singleton-regexp "b"))
  (define singleton-c (singleton-regexp "c"))

  ;;concat-regexp tests
  (check-equal?
   (concat-regexp-r1 (concat-regexp singleton-a singleton-b))
   singleton-a)
  (check-equal?
   (concat-regexp-r2 (concat-regexp singleton-a singleton-b))
   singleton-b)
  (check-exn
   #rx"Step five of the design recipe for regular expressions has not been successfully completed.
The first argument to concat-regexp must be a regular expression, but found: \"a\""
   (lambda () (concat-regexp "a" singleton-b))
   )
  (check-exn
   #rx"Step five of the design recipe for regular expressions has not been successfully completed.
The second argument to concat-regexp must be a regular expression, but found: 7"
   (lambda () (concat-regexp singleton-a 7))
   )
  (check-exn
   #rx"Step four of the design recipe for regular expressions has not been successfully completed.
The expected list of words generated by the regular expression is not a valid list of words: \\(\\(a b\\) 5\\)"
   (lambda () (concat-regexp singleton-a singleton-b #:in-lang '((a b) 5)))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The given regexp alphabet must be a list: 5"
   (lambda () (concat-regexp singleton-a singleton-b #:sigma 5))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The following values, \\(b\\), are duplicated in the given sigma: \\(a b b\\)"
   (lambda () (concat-regexp singleton-a singleton-b #:sigma '(a b b)))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The following: \\(BB\\) are not valid alphanumeric symbols in the given input alphabet: \\(a BB\\)"
   (lambda () (concat-regexp singleton-a singleton-b #:sigma '(a BB)))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The following singletons: \\(b\\) are found in words generated by the regular expression, but not in the specified alphabet: \\(a c\\)"
   (lambda () (concat-regexp singleton-a singleton-b #:sigma '(a c)))
   )
  (check-equal?
   (concat-regexp-r1 (concat-regexp singleton-a singleton-b #:sigma '(a b)))
   (singleton-regexp "a"))
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words are expected to be generated by the constructed concat-regexp but are not generated: \\(\\(a a\\)\\)"
   (lambda () (concat-regexp singleton-a singleton-b #:in-lang '((a a) (a b))))
   )
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words are expected to not be generated by the constructed concat-regexp but are generated: \\(\\(a b\\)\\)"
   (lambda () (concat-regexp singleton-a singleton-b #:not-in-lang '((a a) (a b))))
   )
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words to be generated by the regular expression: \\(\\(a c\\)\\) contain characters not in the regular expression's alphabet: \\(a b\\)"
   (lambda () (concat-regexp singleton-a singleton-b #:in-lang '((a b) (a c))))
   )
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words not to be generated by the regular expression: \\(\\(d e\\)\\) contain characters not in the regular expression's alphabet: \\(a b\\)"
   (lambda () (concat-regexp singleton-a singleton-b #:not-in-lang '((a a) (d e))))
   )
  (check-equal?
   (concat-regexp-r1 (concat-regexp
                      singleton-a
                      singleton-b
                      #:pred (lambda (word) (equal? word '(a b)))
                      #:in-lang '((a b))
                      #:not-in-lang '((a) (b))
                      #:sigma '(a b)))
   singleton-a)
  (check-exn
   #rx"Step three of the design recipe for regular expressions has not been successfully completed.
The given predicate does not hold for the following words generated using the regexp: \\(\\(a b\\)\\)"
   (lambda () (concat-regexp singleton-a singleton-b #:pred (lambda (x) #f)))
   )
  (check-exn
    #rx"Step three of the design recipe for regular expressions has not been successfully completed.
Instead of returning a Boolean, the function given as a predicate returned: 5"
   (lambda () (concat-regexp singleton-a singleton-b #:pred (lambda (x) 5)))
  )
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The number of generated test cases to check with the predicate must be a positive integer, but found: a"
   (lambda () (concat-regexp singleton-a singleton-b #:gen-cases 'a #:pred (lambda (x) #true)))
   )
  

  (define concat-ab (concat-regexp singleton-a singleton-b))

  ;; union-regexp tests
  (check-equal?
   (union-regexp-r1 (union-regexp concat-ab singleton-c))
   concat-ab)
  (check-equal?
   (union-regexp-r2 (union-regexp concat-ab singleton-c))
   singleton-c)
  (check-exn
   #rx"Step five of the design recipe for regular expressions has not been successfully completed.
The first argument to union-regexp must be a regular expression, but found: \"ab\""
   (lambda () (union-regexp "ab" singleton-c))
   )
  (check-exn
   #rx"Step five of the design recipe for regular expressions has not been successfully completed.
The second argument to union-regexp must be a regular expression, but found: 8"
   (lambda () (union-regexp concat-ab 8))
   )
  (check-equal?
   (union-regexp-r1 (union-regexp singleton-a singleton-b #:pred (lambda (word) (or (equal? word '(a)) (equal? word '(b))))))
   singleton-a)
  (check-exn
   #rx"Step three of the design recipe for regular expressions has not been successfully completed.
Instead of returning a Boolean, the function given as a predicate returned: 5"
   (lambda () (union-regexp singleton-a singleton-b #:pred (lambda (x) 5)))
   )
  (check-exn
   #rx"Step three of the design recipe for regular expressions has not been successfully completed.
The given predicate does not hold for the following words generated using the regexp: \\(\\(a\\)\\)"
   (lambda () (union-regexp singleton-a singleton-a #:pred (lambda (x) #f)))
   )
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words are expected to be generated by the constructed union-regexp but are not generated: \\(\\(a b\\)\\)"
   (lambda () (union-regexp singleton-a singleton-b #:in-lang '((a) (b) (a b))))
   )
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words are expected to not be generated by the constructed union-regexp but are generated: \\(\\(b\\)\\)"
   (lambda () (union-regexp singleton-a singleton-b #:not-in-lang '((a b) (b))))
   )
  (check-equal?
   (union-regexp-r1 (union-regexp singleton-a singleton-b #:in-lang '((a) (b))))
   singleton-a)
  (check-equal?
   (union-regexp-r1 (union-regexp singleton-a singleton-b #:not-in-lang '((a b) (b a))))
   singleton-a)
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words to be generated by the regular expression: \\(\\(d e\\) \\(b c\\)\\) contain characters not in the regular expression's alphabet: \\(a b\\)"
   (lambda () (union-regexp singleton-a singleton-b #:in-lang '((a) (b) (d e) (b c))))
   )
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words not to be generated by the regular expression: \\(\\(d e\\) \\(b c\\)\\) contain characters not in the regular expression's alphabet: \\(a b\\)"
   (lambda () (union-regexp singleton-a singleton-b #:not-in-lang '((a) (b) (d e) (b c))))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The given regexp alphabet must be a list: 5"
   (lambda () (union-regexp singleton-a singleton-b #:sigma 5))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The following: \\(BB\\) are not valid alphanumeric symbols in the given input alphabet: \\(a BB\\)"
   (lambda () (union-regexp concat-ab singleton-c #:sigma '(a BB)))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The following values, \\(b\\), are duplicated in the given sigma: \\(a b b\\)"
   (lambda () (union-regexp concat-ab singleton-c #:sigma '(a b b)))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The following singletons: \\(c\\) are found in words generated by the regular expression, but not in the specified alphabet: \\(a b\\)"
   (lambda () (union-regexp concat-ab singleton-c #:sigma '(a b)))
   )
  (check-equal?
   (union-regexp-r1 (union-regexp concat-ab singleton-c #:sigma '(a b c)))
   concat-ab)
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The number of generated test cases to check with the predicate must be a positive integer, but found: a"
   (lambda () (union-regexp singleton-a singleton-b #:gen-cases 'a #:pred (lambda (x) #true)))
   )

  ;; kleenestar-regexp tests
  (check-equal?
   (kleenestar-regexp-r1 (kleenestar-regexp singleton-a))
   singleton-a)
  (check-exn
   #rx"Step five of the design recipe for regular expressions has not been successfully completed.
The argument to kleenestar-regexp must be a regular expression, but found: \"a\""
   (lambda () (kleenestar-regexp (kleenestar-regexp "a")))
   )
  (check-equal?
   (kleenestar-regexp-r1 (kleenestar-regexp
                          singleton-a
                          #:pred (lambda (word) (or (equal? word EMP)
                                                    (and (list? word)
                                                         (andmap (lambda (x) (equal? x 'a)) word))))))
   singleton-a)
  (check-exn
   #rx"Step three of the design recipe for regular expressions has not been successfully completed.
Instead of returning a Boolean, the function given as a predicate returned: 5"
   (lambda () (kleenestar-regexp singleton-a #:pred (lambda (x) 5)))
   )
  (check-exn
   #rx"Step three of the design recipe for regular expressions has not been successfully completed.
The given predicate does not hold for the following words generated using the regexp: \\(Îµ\\)"
   (lambda () (kleenestar-regexp (empty-regexp) #:pred (lambda (x) #f)))
   )
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words are expected to not be generated by the constructed kleenestar-regexp but are generated: \\(\\(a\\) \\(a a\\)\\)"
   (lambda () (kleenestar-regexp singleton-a #:not-in-lang '((a) (a a))))
   )
  (check-equal?
   (kleenestar-regexp-r1 (kleenestar-regexp singleton-a #:in-lang '((a) (a a a a))))
   singleton-a)
  (check-equal?
   (kleenestar-regexp-r1 (kleenestar-regexp concat-ab #:not-in-lang '((b) (b a b))))
   concat-ab)
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words to be generated by the regular expression: \\(\\(b\\) \\(d e\\) \\(b c\\)\\) contain characters not in the regular expression's alphabet: \\(a\\)"
   (lambda () (kleenestar-regexp singleton-a #:in-lang '((a) (b) (d e) (b c))))
   )
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The following words not to be generated by the regular expression: \\(\\(b\\) \\(d e\\) \\(b c\\)\\) contain characters not in the regular expression's alphabet: \\(a\\)"
   (lambda () (kleenestar-regexp singleton-a #:not-in-lang '((a) (b) (d e) (b c))))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The given regexp alphabet must be a list: 5"
   (lambda () (kleenestar-regexp singleton-a #:sigma 5))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The following: \\(BB\\) are not valid alphanumeric symbols in the given input alphabet: \\(a BB\\)"
   (lambda () (kleenestar-regexp concat-ab #:sigma '(a BB)))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The following values, \\(b\\), are duplicated in the given sigma: \\(a b b\\)"
   (lambda () (kleenestar-regexp concat-ab #:sigma '(a b b)))
   )
  (check-exn
   #rx"Step one of the design recipe for regular expressions has not been successfully completed.
The following singletons: \\(c\\) are found in words generated by the regular expression, but not in the specified alphabet: \\(a b\\)"
   (lambda () (kleenestar-regexp singleton-c #:sigma '(a b)))
   )
  (check-equal?
   (kleenestar-regexp-r1 (kleenestar-regexp concat-ab #:sigma '(a b)))
   concat-ab)
  (check-exn
   #rx"Step six of the design recipe for regular expressions has not been successfully completed.
The number of generated test cases to check with the predicate must be a positive integer, but found: a"
   (lambda () (kleenestar-regexp singleton-a #:gen-cases 'a #:pred (lambda (x) #true)))
   )

  
  

  (define ab*Uba* 
    (let* [(A       (singleton-regexp "a"))
           (B       (singleton-regexp "b"))
           (ASTAR   (kleenestar-regexp A))
           (BSTAR   (kleenestar-regexp B))
           (A-BSTAR (concat-regexp A BSTAR))
           (B-ASTAR (concat-regexp B ASTAR))
           (in-ab*Uba* 
            (lambda (w)
              (and (not (null? w))
                   (or (and (eq? (car w) 'a) 
                            (andmap (lambda (s) (eq? s 'b)) (cdr w)))
                       (and (eq? (car w) 'b) 
                            (andmap (lambda (s) (eq? s 'a)) (cdr w)))))))]
      (union-regexp 
       A-BSTAR
       B-ASTAR
       #:pred        in-ab*Uba*
       #:gen-cases   3
       #:sigma       '(a b)
       #:in-lang     '((a) (b) (a b) (a b b b) (b a a a a))
       #:not-in-lang '(() (a a a) (b b) (b a a a a b) (a b b b a a a b a)))))
  )
