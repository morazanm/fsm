#lang racket

(require  "../fsm-core/private/constants.rkt"
          "context-free-expressions-constructors.rkt"
          "../fsm-core/private/cfg.rkt"
          "../fsm-core/private/pda.rkt"
          ;"../visualizations/viz-grammar-constructors/cfg-derive-leftmost.rkt"
          "../sm-graph.rkt"
          rackunit)

(define WORD-AMOUNT 100)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CFEXP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define EMPTY (empty-cfexp))

(define A (singleton-cfexp 'a))

(define B (singleton-cfexp 'b))

(define C (singleton-cfexp 'c))

;; w = ww^r
(define WWR
  (let* [(WWR (var-cfexp 'S))
         (AHA (concat-cfexp A WWR A))
         (BHB (concat-cfexp B WWR B))]
    (begin
      (update-binding! WWR 'S (union-cfexp EMPTY AHA BHB))
      WWR)))

;;w = a^nb^n
(define ANBN
  (let* [(ANBN (var-cfexp 'S))
         (ASB (concat-cfexp A ANBN B))]
    (begin
      (update-binding! ANBN 'S (union-cfexp EMPTY ASB))
      ANBN)))

(define WWRUANBN (union-cfexp WWR ANBN))

;;w = a^2ib^i
(define A2iBi
  (let* [(A2iBi (var-cfexp 'S))
         (EUAAKB (union-cfexp EMPTY (concat-cfexp A A A2iBi B)))]
    (begin
      (update-binding! A2iBi 'S EUAAKB)
      A2iBi)))

;;w = A^iB^j | i <= j <= 2i
(define AiBj
  (let* [(AiBj (var-cfexp 'A))
         (AIB (concat-cfexp A AiBj B))
         (AIBB (concat-cfexp A AiBj B B))
         (EUAIBUAIBB (union-cfexp EMPTY AIB AIBB))]
    (begin
      (update-binding! AiBj 'A EUAIBUAIBB)
      AiBj)))

;;w = b^na^n
(define BNAN
  (let* [(BNAN (var-cfexp 'S))
         (BSA (concat-cfexp B BNAN A))]
    (begin
      (update-binding! BNAN 'S (union-cfexp EMPTY BSA))
      BNAN)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Generating Words;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;cfe natnum -> (listof word)
;;Purpose: Generates at MOST natnum amount of words generated by the given cfe
(define (gen-cfe-words cfe a-num)
  ;; (setof word) -> (setof word)
  ;;Purpose: Generates a natnum amount of generated words
  (define (loopinator-helper acc)
    (if (= (set-count acc) a-num)
        acc
        (loopinator-helper (set-add acc (gen-cfexp-word cfe)))))
  (set->list (loopinator-helper (set))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Langauge Predicates;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;word -> boolean
;;Purpose: Determines if the given word is a valid word for w = ww^r
(define (valid-wwr-word? w)
  (or (eq? w EMP)
      (let* ([w-length (length w)]
             [half-w (take w (/ w-length 2))]
             [w^r (drop w (/ w-length 2))])
        (and (even? w-length)
             (equal? w (append half-w w^r))
             (equal? (reverse half-w) w^r)
             (equal? half-w (reverse w^r))))))

;;word -> boolean
;;Purpose: Determines if the given word is a valid word for w = a^nb^n
(define (valid-anbn-word? w)
  (or (eq? w EMP)
      (let ([as (filter (λ (s) (eq? s 'a)) w)]
            [bs (filter (λ (s) (eq? s 'b)) w)])
        (and (even? (length w))
             (equal? w (append as bs))
             (= (length as) (length bs))))))

;;word -> boolean
;;Purpose: Determines if the given word is a valid word for w = b^na^n
(define (valid-bnan-word? w)
  (or (eq? w EMP)
      (let ([as (filter (λ (s) (eq? s 'a)) w)]
            [bs (filter (λ (s) (eq? s 'b)) w)])
        (and (even? (length w))
             (equal? w (append bs as))
             (= (length as) (length bs))))))

;;word -> boolean
;;Purpose: Determines if the given word is a valid word for w = a^2ib^i
(define (valid-a2ibi-word? w)
  (or (eq? w EMP)
      (let ([as (filter (λ (s) (eq? s 'a)) w)]
            [bs (filter (λ (s) (eq? s 'b)) w)])
        (and (equal? w (append as bs))
             (= (length as) (* 2 (length bs)))))))

;;word -> boolean
;;Purpose: Determines if the given word is a valid word for w = A^iB^j | i <= j <= 2i
(define (valid-aibj-word? w)
  (or (eq? w EMP)
      (let ([as (filter (λ (s) (eq? s 'a)) w)]
            [bs (filter (λ (s) (eq? s 'b)) w)])
        (and (equal? w (append as bs))
             (<= (length as) (length bs) (* 2 (length as)))))))

;;word -> boolean
;;Purpose: Determines if the given word is a valid word for w = a*
(define (valid-A*-word? a-word)
  (or (eq? a-word EMP)
      (andmap (λ (w) (eq? w 'a)) a-word)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;LANGUAGE BANK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define WWR-WORDS (gen-cfe-words WWR WORD-AMOUNT))

(define ANBN-WORDS (gen-cfe-words ANBN WORD-AMOUNT))

(define BNAN-WORDS (gen-cfe-words BNAN WORD-AMOUNT))

(define A2iBi-WORDS (gen-cfe-words A2iBi WORD-AMOUNT))

(define AiBj-WORDS (gen-cfe-words AiBj WORD-AMOUNT))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;TESTING;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(check-pred (λ (low) (andmap valid-wwr-word? low)) WWR-WORDS)

(check-pred (λ (low) (andmap valid-anbn-word? low)) ANBN-WORDS)

(check-pred (λ (low) (andmap valid-bnan-word? low)) BNAN-WORDS)

(check-pred (λ (low) (andmap valid-a2ibi-word? low)) A2iBi-WORDS)

(check-pred (λ (low) (andmap valid-aibj-word? low)) AiBj-WORDS)

(define test (union-cfexp ANBN BNAN))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CFG->CFE & CFE->CFG Transformations;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;w = a^nb^n
(define ANBN-cfg (make-unchecked-cfg '(S)
                                     '(a b)
                                     `((S ,ARROW ,EMP) (S ,ARROW aSb))
                                     'S))

;;w = a^nb^n
(define transformed-anbn (cfg->cfe ANBN-cfg))


(define TRANSFORMED-ANBN-WORDS (gen-cfe-words transformed-anbn WORD-AMOUNT))

(define TRANSFORMED-BNAN-WORDS (gen-cfe-words (cfg->cfe (cfe->cfg BNAN)) WORD-AMOUNT))

(define TRANSFORMED-WWR-WORDS (gen-cfe-words (cfg->cfe (cfe->cfg WWR)) WORD-AMOUNT))

(define TRANSFORMED-AiBj-WORDS (gen-cfe-words (cfg->cfe (cfe->cfg AiBj)) WORD-AMOUNT))

(define TRANSFORMED-A2iBi-WORDS (gen-cfe-words (cfg->cfe (cfe->cfg A2iBi)) WORD-AMOUNT))

;;w = a*
(define thesis-cfg (make-unchecked-cfg '(S T U)
                                       '(a)
                                       `((S ,ARROW aST) (S ,ARROW U)
                                                        (T ,ARROW TU) (T ,ARROW S)
                                                        (U ,ARROW ,EMP))
                                       'S))

;;w = a*
(define transformed-thesis (cfg->cfe thesis-cfg))


;;cfe->cfg

;;w = (ab)*c
(define AB^NC
  (let* [(AB^NC (var-cfexp 'S))
         (ABX (concat-cfexp A B AB^NC))]
    (begin
      (update-binding! AB^NC 'S (union-cfexp C ABX))
      AB^NC)))

;;w = (ab)*c
(define abnc (make-unchecked-cfg '(X)
                                 '(a b c)
                                 `((X ,ARROW c) (X ,ARROW abX))
                                 'X))
;;w = (abc)^na^n
(define thesis-cfe
  (let* [(X (var-cfexp 'X))
         (Y (var-cfexp 'Y))
         (ABY (concat-cfexp A B Y))
         (CXA (concat-cfexp C X A))]
    (begin
      (update-binding! X 'X (union-cfexp EMPTY ABY))
      (update-binding! Y 'Y CXA)
      X)))

;;w = (abc)^na^n
(define thesis-cfe2
  (let* [(X (var-cfexp 'X))
         (Y (var-cfexp 'Y))
         (ABY (concat-cfexp A B Y))
         (CXA (concat-cfexp C X A))]
    (begin
      (update-binding! X 'X EMPTY)
      (update-binding! X 'X ABY)
      (update-binding! Y 'Y CXA)
      X)))

;;w = (abc)^na^n
(define thesis-cfg1 (make-unchecked-cfg '(X Y)
                                        '(a b c)
                                        `((X ,ARROW abY) (X ,ARROW ,EMP)
                                                         (Y ,ARROW cXa))
                                        'X))

;;cfg cfexp natnum -> boolean
;;Purpose: Determines if the given cfe can generate a natnum amount of words that the grammar can derive
(define (grammar-checker g words)
  (for/and ([w (in-list words)])
    (list? (cfg-derive g (if (eq? w EMP) '() w)))))

;;CFE->CFG

;;w = (abc)^na^n
(define thesis-cfg-converted (cfg->cfe thesis-cfg1))

;;w = (abc)^na^n
(define thesis-cfe-converted (cfe->cfg thesis-cfe))

;;TESTING

(define thesis-cfg-converted-WORDS (gen-cfe-words thesis-cfg-converted WORD-AMOUNT))

(define thesis-cfe-WORDS (gen-cfe-words thesis-cfe WORD-AMOUNT))

(check-pred (λ (low) (andmap valid-anbn-word? low)) TRANSFORMED-ANBN-WORDS)

(check-pred (λ (low) (andmap valid-bnan-word? low)) TRANSFORMED-BNAN-WORDS)

(check-pred (λ (low) (andmap valid-wwr-word? low)) TRANSFORMED-WWR-WORDS)

(check-pred (λ (low) (andmap valid-a2ibi-word? low)) TRANSFORMED-A2iBi-WORDS)

(check-pred (λ (low) (andmap valid-aibj-word? low)) TRANSFORMED-AiBj-WORDS)

(check-equal? (grammar-checker thesis-cfg1 thesis-cfg-converted-WORDS) #t)

(check-equal? (grammar-checker thesis-cfe-converted thesis-cfe-WORDS) #t)

(check-equal? (grammar-checker (cfe->cfg ANBN) TRANSFORMED-ANBN-WORDS) #t)

(check-equal? (grammar-checker (cfe->cfg BNAN) TRANSFORMED-BNAN-WORDS) #t)

(check-equal? (grammar-checker (cfe->cfg AiBj) TRANSFORMED-AiBj-WORDS) #t)

(check-equal? (grammar-checker (cfe->cfg A2iBi) TRANSFORMED-A2iBi-WORDS) #t)

(check-equal? (grammar-checker (cfe->cfg WWR) TRANSFORMED-WWR-WORDS) #t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;PDA->CFE & CFE->PDA Transformations;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;PDA->CFE

;;w = a*
(define A* (make-unchecked-ndpda '(S)
                                '(a b)
                                '(a)
                                'S
                                '(S)
                                `(((S a ,EMP) (S ,EMP)))))
;;w = a*
(define A*-cfe (pda->cfe A*))

;;w = a^nb^n
(define converted-ANBN (pda->cfe (cfe->pda ANBN)))

;;pda cfexp natnum -> boolean
;;Purpose: Determines if the given cfe can generate a natnum amount of words that the pda can accept
(define (pda-checker p words)
  (for/and ([w (in-list words)])
    (eq? (apply-pda p (if (eq? w EMP) '() w)) 'accept)))


(define A*-WORDS (gen-cfe-words A*-cfe WORD-AMOUNT))

(define converted-ANBN-WORDS (gen-cfe-words converted-ANBN WORD-AMOUNT))

(define converted-BNAN-WORDS (gen-cfe-words (pda->cfe (cfe->pda BNAN)) WORD-AMOUNT))

(define converted-WWR-WORDS (gen-cfe-words (pda->cfe (cfe->pda WWR)) WORD-AMOUNT))

(define converted-A2iBi-WORDS (gen-cfe-words (pda->cfe (cfe->pda A2iBi)) WORD-AMOUNT))

(define converted-AiBj-WORDS (gen-cfe-words (pda->cfe (cfe->pda AiBj)) WORD-AMOUNT))

(check-pred (λ (low) (andmap valid-A*-word? low)) A*-WORDS)

(check-pred (λ (low) (andmap valid-anbn-word? low)) converted-ANBN-WORDS)

(check-pred (λ (low) (andmap valid-bnan-word? low)) converted-BNAN-WORDS)

(check-pred (λ (low) (andmap valid-wwr-word? low)) converted-WWR-WORDS)

(check-pred (λ (low) (andmap valid-a2ibi-word? low)) converted-A2iBi-WORDS)

(check-pred (λ (low) (andmap valid-aibj-word? low)) converted-AiBj-WORDS)

(check-equal? (pda-checker (cfe->pda ANBN) converted-ANBN-WORDS) #t)

(check-equal? (pda-checker (cfe->pda BNAN) converted-BNAN-WORDS) #t)

(check-equal? (pda-checker (cfe->pda AiBj) converted-AiBj-WORDS) #t)

(check-equal? (pda-checker (cfe->pda A2iBi) converted-A2iBi-WORDS) #t)

(check-equal? (pda-checker (cfe->pda WWR) converted-WWR-WORDS) #t)
