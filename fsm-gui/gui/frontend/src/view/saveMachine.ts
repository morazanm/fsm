import { MachineType, State, isTmType, ruleToString } from '../types/machine';
import { MachineState } from './MainView';
import { writeFileSync, existsSync } from 'fs';

export function saveMachine(filepath: string, machine: MachineState): boolean {
  const date = new Date(Date.now()).toString();
  const headMsg = `;; Generated by FSM-GUI 2.0 on ${date}\n`;
  const machineName = `m-${Math.floor(Math.random() * 3000)}`;
  const invCode = invariantsToString(machine.states, machineName, machine.type);
  const allFSMCode =
    headMsg +
    `(define ${machineName} ${machineToString(machine)})` +
    '\n\n' +
    invCode;

  try {
    const exists = existsSync(filepath);
    // When we have a new file we need to append #lang fsm
    const dataToWrite = exists ? allFSMCode : '#lang fsm\n' + allFSMCode;
    writeFileSync(filepath, dataToWrite, { flag: 'a' });
    return true;
  } catch (error) {
    return false;
  }
}

function machineToString(machine: MachineState): string {
  switch (machine.type) {
    case 'dfa':
      return dfaNdfaToString(machine);
    case 'ndfa':
      return dfaNdfaToString(machine);
    case 'pda':
      return pdaToString(machine);
    case 'tm':
      return tmMttmToString(machine);
    case 'tm-language-recognizer':
      return tmMttmToString(machine);
    default:
      throw Error('Invalid Machine Type');
  }
}

export function dfaNdfaToString(machine: MachineState): string {
  const states = `'(${machine.states.map((s) => s.name).join(' ')})`;
  const alpha = `'(${machine.alphabet.join(' ')})`;
  const start = `'${
    machine.states.find((s) => s.type === 'start' || s.type === 'startFinal')
      .name ?? ''
  }`;
  const finals = `'(${machine.states
    .filter((s) => s.type === 'final' || s.type === 'startFinal')
    .map((s) => s.name)
    .join(' ')})`;
  const rules = `'(${machine.rules.map((r) => ruleToString(r)).join(' ')})`;
  const noDead = machine.nodead ? "'no-dead" : '';
  return `(make-${machine.type}\n\t${states}\n\t${alpha}\n\t${start}\n\t${finals}\n\t${rules}\n\t${noDead})`;
}

export function pdaToString(machine: MachineState): string {
  const states = `'(${machine.states.map((s) => s.name).join(' ')})`;
  const alpha = `'(${machine.alphabet.join(' ')})`;
  const start = `'${
    machine.states.find((s) => s.type === 'start' || s.type === 'startFinal')
      .name ?? ''
  }`;
  const finals = `'(${machine.states
    .filter((s) => s.type === 'final' || s.type === 'startFinal')
    .map((s) => s.name)
    .join(' ')})`;
  const rules = `'(${machine.rules.map((r) => ruleToString(r)).join(' ')})`;
  const stack = `'(${machine.stackAlpha.join(' ')})`;
  return `(make-pda\n\t${states}\n\t${alpha}\n\t${stack}\n\t${start}\n\t${finals}\n\t${rules})`;
}

export function tmMttmToString(machine: MachineState): string {
  const states = `'(${machine.states.map((s) => s.name).join(' ')})`;
  const alpha = `'(${machine.alphabet.join(' ')})`;
  const start = `'${
    machine.states.find((s) => s.type === 'start' || s.type === 'startFinal')
      .name ?? ''
  }`;
  const finals = `'(${machine.states
    .filter(
      (s) =>
        s.type === 'final' || s.type === 'startFinal' || s.type === 'accept',
    )
    .map((s) => s.name)
    .join(' ')})`;
  const rules = `'(${machine.rules.map((r) => ruleToString(r)).join(' ')})`;
  const accept = machine.accept ? `\n\t'${machine.accept.name}` : '';

  return `(make-tm\n\t${states}\n\t${alpha}\n\t${rules}\n\t${start}\n\t${finals}${accept})`;
}

export function invariantsToString(
  states: State[],
  mName: string,
  mType: MachineType,
): string {
  const typeName = isTmType(mType) ? 'tm' : mType;
  const header = `(define-invariants-for-${typeName} ${mName}\n`;
  const funcs = states
    .filter((s) => s.invFunc != null)
    .map((s) => {
      try {
        console.log(s.invFunc);
        const trimmedStr = s.invFunc.replace(/\(define *\(/g, '');
        const fName = trimmedStr.match(/^\S*/g)[0];
        return trimmedStr.replace(/^\S* */g, `\t(define-invariant ${fName} (`);
      } catch (e) {
        return s.invFunc;
      }
    })
    .join('\n');
  return header + funcs + '\n)';
}
