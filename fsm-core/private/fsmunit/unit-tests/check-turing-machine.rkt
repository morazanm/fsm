#lang racket/base

(require "../syntax-value-struct.rkt"
         racket/contract/base
         "../../sm-getters.rkt"
         racket/list
         syntax/parse
         "../fsm-syntax-classes.rkt"
         "../../sm-apply.rkt"
         "../macro-subexpr-contract.rkt"
         "../fsm-error-types/tm-error-types.rkt")

(provide check-turing-machine)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TURING MACHINE CONTRACTS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; use ~or to have different highlighting for expressions that evaluate to list/number vs literal lists
;; 4 cases: one expression to be evauluated, two expressions to be evaluated, literal list and expression, expression and head pos

;; tm test case error precedence
;; Need to raise errors in this order because of likelihood caught issue means errors lower in priority were caused by caught error
;; 1. Incorrect arity -- All bets are off on anything being correct
;; 2. NaN head position(s) -- Very likely creation of list was incorrect
;; NOTE: Order precedence of these are unimportant, just need to be below level 1 and 2
;; 3.0 Non-natural number head position -- Possibly incorrect number is being generated by expression OR user has mistyped
;; 3.1 Missing left hand marker(s) -- Possibly incorrect word is being generated by expression OR user has mistyped
;; 3.2 Invalid word element(s) -- Possibly incorrect word is being generated by expression OR user has mistyped

(define (valid-tm-word/c M) (listof (apply or/c (cons '@ (cons '_ (sm-sigma M))))))
(define (valid-head-pos/c word-len) (and/c exact-nonnegative-integer? (lambda (num) (< num word-len))))
(define correct-tm-word-arity/c (list/c any/c any/c))
(define has-left-hand-marker/c (cons/c '@ (listof any/c)))
(define nan-head-position/c number?)

(define (map-to-val invalid-exprs all-exprs map-to-vals)
  (let ([idxs (map (lambda (x) (index-of all-exprs x)) invalid-exprs)])
    (map (lambda (x) (list-ref map-to-vals x)) idxs)))

(define (build-contract lst-deps)
  (map (lambda (x) (lambda (y) (> (length x) y))) lst-deps))      

(define (check-subexprs M orig-vals unprocessed-words head-posns accept?)
  (check-syntax (property-check correct-tm-word-arity/c
                                orig-vals
                                warn:fsm:app:tm:invalid-arity
                                M)
                (property-check list?
                                unprocessed-words
                                warn:fsm:app:tm:invalid-word
                                M)
                (property-check (map (lambda (x) (valid-head-pos/c (length x)))
                                     (map val-stx-pair-val unprocessed-words))
                                head-posns
                                (lambda (fsm-expr err-vals)
                                  (warn:fsm:app:tm:invalid-head-pos fsm-expr
                                                                    err-vals
                                                                    (lambda (vals)
                                                                      (map-to-val (map val-stx-pair-stx vals)
                                                                                  (map val-stx-pair-stx head-posns)
                                                                                  (map val-stx-pair-val unprocessed-words)))))
                                M)
                (property-check (build-contract (map val-stx-pair-val unprocessed-words))
                                head-posns
                                (lambda (fsm-expr err-vals)
                                  (warn:fsm:app:tm:invalid-head-pos-index fsm-expr
                                                                          err-vals
                                                                          (lambda (vals)
                                                                            (map-to-val (map val-stx-pair-stx vals)
                                                                                        (map val-stx-pair-stx head-posns)
                                                                                        (map val-stx-pair-val unprocessed-words)))))
                                M)
                (property-check has-left-hand-marker/c
                                unprocessed-words
                                warn:fsm:app:tm:no-left-hand-marker
                                M)
                (property-check (valid-tm-word/c (val-stx-pair-val M))
                                unprocessed-words
                                warn:fsm:app:tm:invalid-nt
                                M)
                (if accept?
                    (property-check (map (lambda (head-pos)
                                           (lambda (val) (eq? (sm-apply (val-stx-pair-val M) val head-pos)
                                                              'accept)))
                                         (map val-stx-pair-val head-posns))
                                    unprocessed-words
                                    warn:fsm:app:tm:accept
                                    M)
                    (property-check (map (lambda (head-pos)
                                           (lambda (val) (eq? (sm-apply (val-stx-pair-val M) val head-pos)
                                                              'reject)))
                                         (map val-stx-pair-val head-posns))
                                    unprocessed-words
                                    warn:fsm:app:tm:reject
                                    M))))

(define (parse-input M test-cases accept?)
  ;; results doesn't need to be a fold anymore can just be a map
  (let* ([results (map (lambda (val)
                         (syntax-parse val
                           [(~var list-two-exprs list-tm-word)
                            (list #'list-two-exprs #'list-two-exprs.word #'list-two-exprs.head-pos)]
                           [(~var quoted-two-exprs quoted-tm-word)
                            (list #'quoted-two-exprs #'quoted-two-exprs.word #'quoted-two-exprs.head-pos)]
                           [(~var quasiquoted-two-exprs quasiquoted-tm-word)
                            (list #'quasiquoted-two-exprs #'quasiquoted-two-exprs.word #'quasiquoted-two-exprs.head-pos)]
                           [(~var else-clause)
                            'err-parsing]))
                       (map val-stx-pair-stx test-cases))]
         [head-pos-stx-lst (map (lambda (orig-lst-elem results-elem)
                                  (if (list? results-elem)
                                      (list orig-lst-elem
                                            (val-stx-pair (first (val-stx-pair-val orig-lst-elem)) (second results-elem))
                                            (val-stx-pair (second (val-stx-pair-val orig-lst-elem)) (third results-elem)))
                                      (list orig-lst-elem
                                            ;; Do this because the error reporting is going to catch this later on
                                            (val-stx-pair (if (list? (val-stx-pair-val orig-lst-elem))
                                                              (if (empty? (val-stx-pair-val orig-lst-elem))
                                                                  '()
                                                                  (first (val-stx-pair-val orig-lst-elem)))
                                                              (val-stx-pair-val orig-lst-elem))
                                                          (val-stx-pair-stx orig-lst-elem))
                                            ;; Do this because the error reporting is going to catch this later on
                                            (val-stx-pair (if (list? (val-stx-pair-val orig-lst-elem))
                                                              (if (and (not (empty? (val-stx-pair-val orig-lst-elem)))
                                                                       (not (empty? (rest (val-stx-pair-val orig-lst-elem)))))
                                                                
                                                                  (second (val-stx-pair-val orig-lst-elem))
                                                                  '())
                                                              (val-stx-pair-val orig-lst-elem))
                                                          (val-stx-pair-stx orig-lst-elem)))))
                                test-cases
                                results)])
    (check-subexprs M
                    (map first head-pos-stx-lst)
                    (map second head-pos-stx-lst)
                    (map third head-pos-stx-lst)
                    accept?)))

;; Syntax -> Syntax
;; Matches incorrect syntatic forms and provides specialized errors messages based on them
(define (check-turing-machine accept? M test-cases)
  (parse-input M test-cases accept?))