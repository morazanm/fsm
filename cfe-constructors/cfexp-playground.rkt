#lang racket

(require  "../fsm-core/private/constants.rkt"
          "context-free-expressions-constructors.rkt"
          "../fsm-core/private/cfg.rkt"
          "../visualizations/viz-grammar-constructors/cfg-derive-leftmost.rkt"
          rackunit)

(define EMPTY (empty-cfexp))

(define A (singleton-cfexp 'a))

(define B (singleton-cfexp 'b))

(define C (singleton-cfexp 'c))

;; w = ww^r
(define WWR 
  (local [(define WWR (var-cfexp 'WWR))

          (define AHA (concat-cfexp A WWR A))

          (define BHB (concat-cfexp B WWR B))]
    (begin
      (update-binding! WWR 'WWR (union-cfexp EMPTY AHA BHB))
      WWR)))

;;w = a^nb^n
(define ANBN
  (local [(define ANBN (var-cfexp 'ANBN))

          (define ASB (concat-cfexp A ANBN B))]
    (begin
      (update-binding! ANBN 'ANBN (union-cfexp EMPTY ASB))
      ANBN)))

(define WWRUANBN (union-cfexp WWR ANBN))

;;w = a^2ib^i
(define A2iBi
  (local [(define A2iBi (var-cfexp 'A2iBi))

          (define EUAAKB (union-cfexp EMPTY (concat-cfexp A A A2iBi B)))]
    (begin
      (update-binding! A2iBi 'A2iBi EUAAKB)
      A2iBi)))

;;w = A^iB^j | i <= j <= 2i
(define AiBj
  (local [(define AiBj (var-cfexp 'AiBj))

          (define AIB (concat-cfexp A AiBj B))

          (define AIBB (concat-cfexp A AiBj B B))

          (define EUAIBUAIBB (union-cfexp EMPTY AIB AIBB))]
    (begin
      (update-binding! AiBj 'AiBj EUAIBUAIBB)
      AiBj)))


(define S1
  (local [(define ANBN (var-cfexp 'S))

          (define ASB (concat-cfexp A ANBN B))]
    (begin
      (update-binding! ANBN 'S (union-cfexp EMPTY ASB))
      ANBN)))


(define S2
  (local [(define BNAN (var-cfexp 'S))

          (define BSA (concat-cfexp B BNAN A))]
    (begin
      (update-binding! BNAN 'S (union-cfexp EMPTY BSA))
      BNAN)))


;;cfe natnum -> (listof word)
;;Purpose: Generates at MOST natnum amount of words generated by the given cfe
(define (gen-cfe-words cfe a-num)
  (define (loopinator-helper a-num acc)
    (if (= a-num 0)
        acc
       (loopinator-helper (sub1 a-num) (cons (gen-cfexp-word cfe) acc))))
  (remove-duplicates (loopinator-helper a-num '())))

(define (valid-wwr-word w)
  (or (eq? w EMP)
      (let* ([w-length (length w)]
             [half-w (take w (/ w-length 2))]
             [w^r (drop w (/ w-length 2))])
        (and (even? w-length)
             (equal? w (append half-w w^r))
             (equal? (reverse half-w) w^r)
             (equal? half-w (reverse w^r))))))

(define (valid-anbn-word w)
  (or (eq? w EMP)
      (let ([as (filter (λ (s) (eq? s 'a)) w)]
            [bs (filter (λ (s) (eq? s 'b)) w)])
        (and (even? (length w))
             (equal? w (append as bs))
             (= (length as) (length bs))))))

(define (valid-a2ibi-word w)
  (or (eq? w EMP)
      (let ([as (filter (λ (s) (eq? s 'a)) w)]
            [bs (filter (λ (s) (eq? s 'b)) w)])
        (and (equal? w (append as bs))
             (= (length as) (* 2 (length bs)))))))

(define (valid-aibj-word w)
  (or (eq? w EMP)
      (let ([as (filter (λ (s) (eq? s 'a)) w)]
            [bs (filter (λ (s) (eq? s 'b)) w)])
        (and (equal? w (append as bs))
             (<= (length as) (length bs) (* 2 (length as)))))))


;;TESTING
#|
(check-pred (λ (low) (andmap valid-wwr-word low)) (gen-cfe-words WWR 100000))

(check-pred (λ (low) (andmap valid-anbn-word low)) (gen-cfe-words ANBN 100000))

(check-pred (λ (low) (andmap valid-a2ibi-word low)) (gen-cfe-words A2iBi 100000))

(check-pred (λ (low) (andmap valid-aibj-word low)) (gen-cfe-words AiBj 100000))
|#

(define test (union-cfexp S1 S2))


;;Transformation tests

;;cfg -> cfe
(define ANBN-cfg (make-unchecked-cfg '(S)
                                     '(a b)
                                     `((S ,ARROW ,EMP) (S ,ARROW aSb))
                                     'S))

(define transformed-anbn (cfg->cfe ANBN-cfg))

;(check-pred (λ (low) (andmap valid-anbn-word low)) (gen-cfe-words transformed-anbn 100000))

(define thesis-cfg (make-unchecked-cfg '(S T U)
                                       '(a)
                                       `((S ,ARROW aST) (S ,ARROW U)
                                         (T ,ARROW TU) (T ,ARROW S)
                                         (U ,ARROW ,EMP))
                                       'S))

(define transformed-thesis (cfg->cfe thesis-cfg))


;;cfe->cfg

;;w = (ab)*c
(define AB^NC
  (local [(define AB^NC (var-cfexp 'AB^NC))

          (define ABX (concat-cfexp A B AB^NC))]
    (begin
      (update-binding! AB^NC 'AB^NC (union-cfexp C ABX))
      AB^NC)))

;;w = (ab)*c
(define abnc (make-unchecked-cfg '(X)
                                 '(a b c)
                                 `((X ,ARROW c) (X ,ARROW abX))
                                 'X))
;;w = (abc)^na^n
(define thesis-cfe
  (local [(define X (var-cfexp 'X))

          (define Y (var-cfexp 'Y))

          (define ABY (concat-cfexp A B Y))

          (define CXA (concat-cfexp C X A))]
  (begin
    (update-binding! X 'X (union-cfexp EMPTY ABY))
    (update-binding! Y 'Y CXA)
    X)))

;;w = (abc)^na^n
(define thesis-cfe2
  (local [(define X (var-cfexp 'X))

          (define Y (var-cfexp 'Y))

          (define ABY (concat-cfexp A B Y))

          (define CXA (concat-cfexp C X A))]
  (begin
    (update-binding! X 'X EMPTY)
    (update-binding! X 'X ABY)
    (update-binding! Y 'Y CXA)
    X)))

;;w = (abc)^na^n
(define thesis-cfg1 (make-unchecked-cfg '(X Y)
                                        '(a b c)
                                        `((X ,ARROW abY) (X ,ARROW ,EMP)
                                                         (Y ,ARROW cXa))
                                        'X))

(define (check-grammar g cfe)
  (let ([w (gen-cfexp-word cfe)])
    (cfg-derive g (if (eq? w EMP) '() w))))

(define (grammar-checker g cfe num)
  (let ([res (for/list ([x (in-naturals)])
               #:break (= x num)
               (check-grammar g cfe))])
    ;(displayln res)
    (andmap list? res)))