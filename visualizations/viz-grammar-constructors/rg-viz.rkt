#lang racket/base

(require "../../fsm-gviz/private/lib.rkt"
         "../../fsm-core/private/regular-grammar.rkt"
         "../../fsm-core/private/grammar-getters.rkt"
         "../../fsm-core/private/constants.rkt"
         "../../fsm-core/private/misc.rkt"
         "../viz-lib/zipper.rkt"
         "grammar-viz.rkt"
         racket/list
         )

(provide rg-viz)

(define FONT-SIZE 20)
(define HEDGE-COLOR 'violet)
(define YIELD-COLOR 'skyblue)
(define INVARIANT-HOLDS-COLOR 'green)
(define INVARIANT-BROKEN-COLOR 'red)

;; dgrph is a structure that has
;; up-levels - unprocessed levels
;; ad-levels - levels added to the graph
;; nodes - nodes in the graph
;; hedges - highlighted edges of the graphs
;; up-rules - unprocessed grammar rules
;; p-rules - processed grammar rules
(struct dgrph (up-levels ad-levels nodes hedges up-rules p-rules up-yield-trees p-yield-trees))

;; tree Any -> (U #f tree)
;; Finds the search value within the tree using a depth first search
(define (dfs node search-val)
  (if (equal? (tree-value node) search-val)
      node
      (ormap (lambda (node) (dfs node search-val)) (tree-subtrees node))))

;; A tree has a value and subtrees
;; A value is Any
;; A subtree is a listof Any
(struct tree (value [subtrees #:mutable]) #:transparent)

;; levels -> tree
;; Creates a tree structure from the levels
(define (create-yield-tree levels start-elem)
  (foldl (lambda (val accum)
           (set-tree-subtrees! (dfs accum (car (car val)))
                               (map (lambda (edge) (tree (cadr edge) '())) val))
           accum)
         (tree start-elem '())
         levels))

;; Symbol -> Symbol
;; Removes all numbers from the symbol (that were originally added for differentiating in graphviz)
(define (undo-renaming symb)
  (string->symbol (list->string (takef (string->list (symbol->string symb)) (lambda (x) (not (equal? #\_ x))))
                                )))

;; tree -> listof Symbol
;; Accumulates all of the leave nodes in order (producing the yield of the tree)
(define (get-yield subtree)
  ;; lower?
  ;; symbol -> Boolean
  ;; Purpose: Determines if a symbol is down case
  (define (lower? symbol)
    (not (char-upper-case? (string-ref (symbol->string symbol) 0))))
  (define subtree-copy (struct-copy tree subtree))
  (define (get-yield-helper subtree)
    (foldl (lambda (node yield)
             (cond
               [(equal? (undo-renaming (tree-value node)) EMP) yield]
               [(null? (tree-subtrees node)) (append yield (list (tree-value node)))]
               [else (append yield (get-yield-helper node))]))
           '()
           (tree-subtrees subtree)))
  (filter (lambda (node) (lower? node))
          (foldl (lambda (node yield)
                   (cond
                     [(equal? (undo-renaming (tree-value node)) EMP) yield]
                     [(null? (tree-subtrees node)) (append yield (list (tree-value node)))]
                     [else (append yield (get-yield-helper node))]))
                 '()
                 (tree-subtrees subtree))))

;; tree invariant-function -> (U boolean Symbol)
;; Evaluates the invariant function given to us by the user on the current yield
;; generated by its respective nonterminal
(define (invariant-holds? subtree invar-func)
  (invar-func (map undo-renaming (get-yield subtree))))

;; tree (listof Symbol) (listof (list Symbol ((listof Symbol) -> (U boolean Symbol)) -> (U boolean Symbol)
;; Checks all invariants against all of their respective nodes
(define (check-all-invariants tree nonterminals-to-check invariants)
  (define (check-invariant invariant-nt invariant-func)
    (define (find-all-invariant-nodes nts)
      (if (null? nts)
          '()
          (if (equal? invariant-nt (undo-renaming (car nts)))
              (cons (car nts) (find-all-invariant-nodes (cdr nts)))
              (find-all-invariant-nodes (cdr nts)))))
    (define (check-all-invariant-nodes nonterminals invar-func broken-nodes)
      (if (null? nonterminals)
          (if (null? broken-nodes) #t broken-nodes)
          (if (invariant-holds? (dfs tree (car nonterminals)) invar-func)
              (check-all-invariant-nodes (cdr nonterminals) invar-func broken-nodes)
              (check-all-invariant-nodes (cdr nonterminals)
                                         invar-func
                                         (cons (car nonterminals) broken-nodes)))))
    (check-all-invariant-nodes (find-all-invariant-nodes nonterminals-to-check)
                               invariant-func
                               '()))
  (define (check-all-invariants-helper nonterminals-to-check invariants broken-nodes)
    (if (null? invariants)
        (if (null? broken-nodes) '() broken-nodes)
        (let ([result (check-invariant (car (car invariants))
                                       (cadr (car invariants)))])
          (if (list? result)
              (check-all-invariants-helper nonterminals-to-check
                                           (cdr invariants)
                                           (append result broken-nodes))
              (check-all-invariants-helper nonterminals-to-check
                                           (cdr invariants)
                                           broken-nodes)))))
  (check-all-invariants-helper nonterminals-to-check invariants '()))

;; levels -> (listof levels)
;; Creates a list containing the levels used for each graph generated
(define (create-list-of-levels levels)
  (define (create-list-of-levels-helper lvls)
    (if (null? lvls) '() (cons lvls (create-list-of-levels-helper (cdr lvls)))))
  (create-list-of-levels-helper (reverse levels)))

;; upper?
;; symbol -> Boolean
;; Purpose: Determines if a symbol is upper case
(define (upper? symbol)
  (char-upper-case? (string-ref (symbol->string symbol) 0)))

;; lower?
;; symbol -> Boolean
;; Purpose: Determines if a symbol is down case
(define (lower? symbol)
  (not (char-upper-case? (string-ref (symbol->string symbol) 0))))

;; create-edges
;; (listof level) <=> (listof (listof edge))
;; (listof symbol) -> (listof (listof edge))
;; Purpose: To create edges of the graph and group them by levels
(define (create-edges wd)
  (cond
    [(null? wd) '()]
    [(= 1 (length wd)) (list (list (list (last (car wd)) null)))]
    [(= 2 (length wd))
     (if (equal? (length (car wd)) (length (cadr wd)))
         (list (list (list (last (car wd)) (last (cadr wd)))))
         (list (list (list (last (car wd)) EMP))))]
    [else
     (append (list (map (λ (x) (list (last (car wd)) x)) (take-right (cadr wd) 2)))
             (create-edges (cdr wd)))]))

;; create-rules
;; (listof symbol) -> (listof string)
;; Purpose: To create rules for the informative message
(define (create-rules w-der)
  (cond
    [(null? w-der) '()]
    [(= 1 (length w-der)) '()]
    [(= 2 (length w-der))
     (if (equal? (length (car w-der)) (length (cadr w-der)))
         (append (list (string-append (symbol->string (last (car w-der)))
                                      " → "
                                      (symbol->string (last (cadr w-der)))))
                 (create-rules (cdr w-der)))
         (append
          (list (string-append (symbol->string (last (car w-der))) " → " (symbol->string EMP)))
          (create-rules (cdr w-der))))]
    [else
     (append (list (string-append
                    (symbol->string (last (car w-der)))
                    " → "
                    (string-append (car (map symbol->string (take-right (cadr w-der) 2)))
                                   (cadr (map symbol->string (take-right (cadr w-der) 2))))))
             (create-rules (cdr w-der)))]))

(define (rename-symbol nt hashtb)
    (let ([result (hash-ref hashtb nt #f)])
      (if result
          (begin
            (hash-set! hashtb nt (add1 result))
            (string->symbol (format "~s_~s" nt (add1 result))))
          (begin
            (hash-set! hashtb nt 0)
            (string->symbol (format "~s_0" nt))))))

;; rename-edges
;; (listof level) -> (listof level)
;; Purpose: To rename the nonterminals that reoccur in extracted edges
(define (rename-edges exe hash-nt)
  (define (rnm-lvl lvl acc)
    (cond
      [(null? lvl) '()]
      [(= 1 (length lvl)) (list (list (car acc) (cadr (car lvl))) acc)]
      [(member (cadr (cadr lvl)) acc)
       (let ([new-symbol (generate-symbol (cadr (cadr lvl)) acc)])
         (list (list (list (car acc) (cadr (car lvl))) (list (car acc) new-symbol))
               (cons new-symbol acc)))]
      [else
       (list (list (list (car acc) (cadr (car lvl))) (list (car acc) (cadr (cadr lvl))))
             (cons (cadr (cadr lvl)) acc))]))
  (define (rnm-lvls exe accum)
    (if (null? exe)
        '()
        (let* ([new-level-accum (rnm-lvl (car exe) accum)]
               [new-level (car new-level-accum)]
               [new-accum (cadr new-level-accum)])
          (cons new-level (rnm-lvls (cdr exe) new-accum)))))
  (rnm-lvls exe (list (car (car (car exe))))))

;; rename-nodes
;; (listof level) -> (listof level)
;; Purpose: To rename the terminals that reoccur in extracted edges
(define (rename-nodes exe hash-nt)
  (define (rnm-lvl lvl acc)
    (cond
      [(null? lvl) '()]
      [(and (symbol? (car lvl)) (member (cadr lvl) acc))
       (let ([new-symbol (generate-symbol (cadr lvl) acc)])
         (list (list (car lvl) new-symbol) acc))]
      [(and (symbol? (car lvl)) (not (member (cadr lvl) acc)))
       (list (list (car lvl) (cadr lvl)) (cons (cadr lvl) acc))]
      [(member (cadr (car lvl)) acc)
       (let ([new-symbol (generate-symbol (cadr (car lvl)) acc)])
         (list (list (list (car (car lvl)) new-symbol) (cadr lvl)) (cons new-symbol acc)))]
      [else (list (list (car lvl) (cadr lvl)) (cons (cadr (car lvl)) acc))]))
  (define (rnm-lvls exe accum)
    (if (null? exe)
        '()
        (let* ([new-level-accum (rnm-lvl (car exe) accum)]
               [new-level (car new-level-accum)]
               [new-accum (cadr new-level-accum)])
          (cons new-level (rnm-lvls (cdr exe) new-accum)))))
  (if (= 1 (length exe)) exe (rnm-lvls exe (list (cadr (car (car exe)))))))

;; extract-nodes
;; (listof level) -> (listof node)
;; Purpose: To extract nodes from the list of edges - check if this is right
(define (extract-nodes loe)
  (remove-duplicates (flatten loe)))

;; dgrph (listof (list nonterminal predicate)) starting-nonterminal derivation-order
;; Purpose: Creates the list of broken invariants for a given dgrph
(define (create-invariant-nodes a-dgrph invariants root-node)
  (let* ([nodes (dgrph-nodes a-dgrph)]
         [levels (map reverse (dgrph-ad-levels a-dgrph))]
         [producing-nodes (get-producing-nodes (append* levels))]
         [invariant-nodes
          (let ([all-but-starting-nt
                 (append-map (lambda (lvl)
                               (let* ([nodes (map (lambda (edge) (cadr edge))
                                                  (filter (lambda (edge) (not (null? edge))) lvl))])
                                 (filter (lambda (node) (member node producing-nodes)) nodes)))
                             levels)])
            (if (member root-node producing-nodes)
                (cons root-node all-but-starting-nt)
                all-but-starting-nt))]
         [broken-invariants
          (check-all-invariants (car (dgrph-p-yield-trees a-dgrph)) invariant-nodes invariants)])
    broken-invariants))

;; make-node-graph
;; graph lon -> graph
;; Purpose: To make a node graph
(define (make-node-graph graph
                         lon
                         hedge-nodes
                         yield-node
                         broken-invariants?
                         producing-nodes
                         has-invariant)
  (foldl (λ (state result)
           (add-node result
                     state
                     #:atb (hash 'color (cond
                                          [(member state hedge-nodes) HEDGE-COLOR]
                                          [(member state yield-node) YIELD-COLOR]
                                          [else 'black])
                                 'style 'filled
                                 'fillcolor (cond
                                              [(not (member (undo-renaming state) has-invariant))
                                               'white]
                                              [(and (member (undo-renaming state) has-invariant)
                                                    (not (member state producing-nodes)))
                                               'white]
                                              [(and (member (undo-renaming state) has-invariant)
                                                    (member state producing-nodes)
                                                    (member state broken-invariants?))
                                               INVARIANT-BROKEN-COLOR]
                                              [(and (member (undo-renaming state) has-invariant)
                                                    (member state producing-nodes)
                                                    (not (member state broken-invariants?)))
                                               INVARIANT-HOLDS-COLOR])
                                 'shape 'circle
                                 'label (undo-renaming state)
                                 'fontcolor 'black
                                 'font "Sans")))
         graph
         (reverse lon)))

;; make-edge-graph
;; graph (listof level) -> graph
;; Purpose: To make an edge graph
(define (make-edge-graph graph loe hedges)
  (let ([first-foldr
         (foldl (λ (rule result)
                  (if (null? (car rule))
                      result
                      (add-edge result
                                ""
                                (car (car rule))
                                (cadr (car rule))
                                #:atb (hash 'fontsize
                                            FONT-SIZE
                                            'style
                                            (if (member (car rule) hedges)
                                                'dashed
                                                'solid)
                                            'color
                                            (if (member (car rule) hedges) HEDGE-COLOR 'black)))))
                graph
                (reverse loe))])
    (foldl (λ (rule result)
             (if (null? (cadr rule))
                 result
                 (add-edge result
                           ""
                           (car (cadr rule))
                           (cadr (cadr rule))
                           #:atb (hash 'fontsize
                                       20
                                       'style
                                       (if (member (car rule) hedges)
                                           'dashed
                                           'solid)
                                       'color
                                       (if (member (car rule) hedges) HEDGE-COLOR 'black)))))
           first-foldr
           (reverse loe))))

(define (get-producing-nodes levels)
  (if (null? levels)
      '()
      (if (null? (car levels))
          (get-producing-nodes (cdr levels))
          (cons (car (car levels)) (get-producing-nodes (cdr levels))))))

;; create-graph-structs
;; dgprh -> img
;; Purpose: Creates the final graph structure that will be used to create the images in graphviz
(define (create-graph-structs a-dgrph invariants root-node)
  (let* ([nodes (append (filter lower? (dgrph-nodes a-dgrph)) (filter upper? (dgrph-nodes a-dgrph)))]
         [levels (map reverse (dgrph-ad-levels a-dgrph))]
         [reversed-levels (reverse levels)]
         [hedges (dgrph-hedges a-dgrph)]
         [hedge-nodes (map (λ (x) (if (null? x) '() (cadr x))) hedges)]
         [yield-node (map (λ (x) (if (null? x) '() (car x))) hedges)]
         [invariant-nts (map first invariants)]
         [producing-nodes (get-producing-nodes (append* levels))]
         [invariant-nodes
          (cons root-node
                (append-map
                 (lambda (lvl)
                   (filter (lambda (node) (member node producing-nodes))
                                               (map (lambda (edge) (second edge))
                                                    (filter (lambda (edge) (not (empty? edge))) lvl))))
                 levels))
          #;(cons root-node
                (append-map (lambda (lvl)
                              (let* ([nodes (map (lambda (edge) (cadr edge))
                                                 (filter (lambda (edge) (not (null? edge))) lvl))])
                                (filter (lambda (node) (member node producing-nodes)) nodes)))
                            levels))]
         [broken-invariant?
          (check-all-invariants (car (dgrph-p-yield-trees a-dgrph)) invariant-nodes invariants)])
    (make-edge-graph
     (make-node-graph (create-graph 'dgraph #:atb (hash 'rankdir "TB" 'font "Sans" 'ordering "in"))
                      nodes
                      hedge-nodes
                      yield-node
                      broken-invariant?
                      producing-nodes
                      invariant-nts)
     reversed-levels
     hedges)))

;; create-dgraphs
;; dgrph (listof dgrph) -> (listof dgrph)
;; Purpose: To create all the dgrphs for graph imgs
(define (create-dgrphs a-dgrph lod)
  (if (null? (dgrph-up-levels a-dgrph))
      (cons a-dgrph lod)
      (let* ([new-up-levels (cdr (dgrph-up-levels a-dgrph))]
             [new-ad-levels (cons (car (dgrph-up-levels a-dgrph)) (dgrph-ad-levels a-dgrph))]
             [new-nodes (extract-nodes new-ad-levels)]
             [new-hedges (car (dgrph-up-levels a-dgrph))]
             [new-up-rules (cdr (dgrph-up-rules a-dgrph))]
             [new-p-rules (cons (car (dgrph-up-rules a-dgrph)) (dgrph-p-rules a-dgrph))]
             [new-up-yield-trees (cdr (dgrph-up-yield-trees a-dgrph))]
             [new-p-yield-trees (cons (car (dgrph-up-yield-trees a-dgrph))
                                      (dgrph-p-yield-trees a-dgrph))])
        (create-dgrphs (dgrph new-up-levels
                              new-ad-levels
                              new-nodes
                              new-hedges
                              new-up-rules
                              new-p-rules
                              new-up-yield-trees
                              new-p-yield-trees)
                       (cons a-dgrph lod)))))

;; run function
(define (rg-viz rg word #:cpu-cores [cpu-cores #f] . invariants)
  (define rg-derv-res (rg-derive rg word))
  (if (string? rg-derv-res)
      rg-derv-res
      (let* ([derivation (rg-derive-with-rules rg word)]
             [w-der (for/list ([derv-elem (in-list derivation)]
                               #:when (not (equal? (first derv-elem) '->)))
                      (symbol->fsmlos (first derv-elem)))]
             [rules (cons ""
                          (for/list ([derv-elem (in-list (rest derivation))])
                            (string-append (symbol->string (first (second derv-elem)))
                                           " → "
                                           (symbol->string (third (second derv-elem))))))]
             [used-node-names (make-hash)]
             [renamed (rename-nodes (rename-edges (create-edges w-der) used-node-names) used-node-names)]
             [yield-trees (map (lambda (x) (create-yield-tree x (grammar-start rg))) (map reverse (create-list-of-levels (map (λ (el) (if (symbol? (first el))
                                                                                (list el)
                                                                                el))
                                                                    renamed))))]
             [dgraph (dgrph (map (λ (el) (if (symbol? (first el))
                                             (list el '())
                                             el))
                                 renamed)
                            '()
                            '()
                            '()
                            (rest rules)
                            (list (first rules))
                            
                            (map (lambda (x) (first yield-trees))
                                 yield-trees)
                            #;(reverse (for/list ([lvl (in-list (create-list-of-levels
                                                               (map (λ (el) (if (symbol? (first el))
                                                                                (list el)
                                                                                el))
                                                                    renamed)))])
                                       (create-yield-tree (reverse lvl) (grammar-start rg))))
                            (list (tree (grammar-start rg) '())))]
             [lod (reverse (create-dgrphs dgraph '()))]
             [broken-invariants
              (if (null? invariants)
                  'NO-INV
                  (list->zipper
                   (map (lambda (a-dgrph)
                          (remove-duplicates
                           (map undo-renaming
                                (create-invariant-nodes a-dgrph invariants (grammar-start rg)))))
                        lod)))]
             [graphs (map (lambda (dgrph) (create-graph-structs dgrph invariants (grammar-start rg)))
                          lod)])
        (init-viz rg word w-der rules graphs broken-invariants #:special-graphs? 'rg #:cpu-cores cpu-cores)
        )))
(define G (make-unchecked-rg '(S) '(a b) `((S ,ARROW ,EMP) (S ,ARROW aS)) 'S))

(define even-bs-odd-as
  (make-unchecked-rg '(S A B C)
           '(a b)
           `((S ,ARROW aA) (S ,ARROW bB)
                           (S ,ARROW a)
                           (A ,ARROW aS)
                           (A ,ARROW bC)
                           (B ,ARROW aC)
                           (B ,ARROW bS)
                           (C ,ARROW aB)
                           (C ,ARROW bA)
                           (C ,ARROW b))
           'S))
