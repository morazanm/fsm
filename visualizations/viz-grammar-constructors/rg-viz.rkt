#lang racket

(require "../../fsm-gviz/private/lib.rkt"
         rackunit
         "../../fsm-core/interface.rkt"
         "../../fsm-core/private/regular-grammar.rkt"
         "../viz-lib/viz.rkt"
         "../viz-lib/zipper.rkt"
         "grammar-viz.rkt"
         )

(define FNAME "fsm")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define even-bs-odd-as
  (make-rg '(S A B C)
           '(a b)
           `((S ,ARROW aA) (S ,ARROW bB)
                           (S ,ARROW a)
                           (A ,ARROW aS)
                           (A ,ARROW bC)
                           (B ,ARROW aC)
                           (B ,ARROW bS)
                           (C ,ARROW aB)
                           (C ,ARROW bA)
                           (C ,ARROW b))
           'S))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define FONT-SIZE 20)
(define HEDGE-COLOR 'violet)
(define YIELD-COLOR 'skyblue)
(define INVARIANT-HOLDS-COLOR 'green)
(define INVARIANT-BROKEN-COLOR 'red)

;; posn is a structure that has
;; x coordinate
;; y coordinate
(struct posn (x y))

;; dgrph is a structure that has
;; up-levels - unprocessed levels
;; ad-levels - levels added to the graph
;; nodes - nodes in the graph
;; hedges - highlighted edges of the graphs
;; up-rules - unprocessed grammar rules
;; p-rules - processed grammar rules
(struct dgrph (up-levels ad-levels nodes hedges up-rules p-rules up-yield-trees p-yield-trees))

;; tree Any -> (U #f tree)
;; Finds the search value within the tree using a depth first search
(define (dfs node search-val)
  (if (equal? (tree-value node) search-val)
      node
      (ormap (lambda (node) (dfs node search-val)) (tree-subtrees node))))

;; A tree has a value and subtrees
;; A value is Any
;; A subtree is a listof Any
(struct tree (value [subtrees #:mutable]) #:transparent)

;; levels -> tree
;; Creates a tree structure from the levels
(define (create-yield-tree levels)
  (foldl (lambda (val accum)
           (set-tree-subtrees! (dfs accum (first (first val)))
                               (map (lambda (edge) (tree (second edge) '())) val))
           accum)
         (tree 'S '())
         levels))

;; Symbol -> Symbol
;; Removes all numbers from the symbol (that were originally added for differentiating in graphviz)
(define (undo-renaming symb)
  (string->symbol (list->string (filter (lambda (x)
                                          (not (or (equal? #\0 x)
                                                   (equal? #\1 x)
                                                   (equal? #\2 x)
                                                   (equal? #\3 x)
                                                   (equal? #\4 x)
                                                   (equal? #\5 x)
                                                   (equal? #\6 x)
                                                   (equal? #\7 x)
                                                   (equal? #\8 x)
                                                   (equal? #\9 x)
                                                   (equal? #\- x))))
                                        (string->list (symbol->string symb))))))

;; tree -> listof Symbol
;; Accumulates all of the leave nodes in order (producing the yield of the tree)
(define (get-yield subtree)
  (local [;; lower?
          ;; symbol -> Boolean
          ;; Purpose: Determines if a symbol is down case
          (define (lower? symbol)
            (not (char-upper-case? (string-ref (symbol->string symbol) 0))))
          (define subtree-copy (struct-copy tree subtree))
          (define (get-yield-helper subtree)
            (foldl (lambda (node yield)
                     (cond
                       [(equal? (undo-renaming (tree-value node)) EMP) yield]
                       [(empty? (tree-subtrees node)) (append yield (list (tree-value node)))]
                       [else (append yield (get-yield-helper node))]))
                   '()
                   (tree-subtrees subtree)))]
         (filter (lambda (node) (lower? node))
                 (foldl (lambda (node yield)
                          (cond
                            [(equal? (undo-renaming (tree-value node)) EMP) yield]
                            [(empty? (tree-subtrees node)) (append yield (list (tree-value node)))]
                            [else (append yield (get-yield-helper node))]))
                        '()
                        (tree-subtrees subtree)))))

;; tree invariant-function -> (U boolean Symbol)
;; Evaluates the invariant function given to us by the user on the current yield
;; generated by its respective nonterminal
(define (invariant-holds? subtree invar-func)
  (invar-func (map undo-renaming (get-yield subtree))))

;; tree (listof Symbol) (listof (list Symbol ((listof Symbol) -> (U boolean Symbol)) -> (U boolean Symbol)
;; Checks all invariants against all of their respective nodes
(define (check-all-invariants tree nonterminals-to-check invariants)
  (local [(define (check-invariant invariant-nt invariant-func)
            (local [(define (find-all-invariant-nodes nts)
                      (if (empty? nts)
                          '()
                          (if (equal? invariant-nt (undo-renaming (first nts)))
                              (cons (first nts) (find-all-invariant-nodes (rest nts)))
                              (find-all-invariant-nodes (rest nts)))))
                    (define (check-all-invariant-nodes nonterminals invar-func broken-nodes)
                      (if (empty? nonterminals)
                          (if (empty? broken-nodes) #t broken-nodes)
                          (if (invariant-holds? (dfs tree (first nonterminals)) invar-func)
                              (check-all-invariant-nodes (rest nonterminals) invar-func broken-nodes)
                              (check-all-invariant-nodes (rest nonterminals)
                                                         invar-func
                                                         (cons (first nonterminals) broken-nodes)))))]
                   (check-all-invariant-nodes (find-all-invariant-nodes nonterminals-to-check)
                                              invariant-func
                                              '())))
          (define (check-all-invariants-helper nonterminals-to-check invariants broken-nodes)
            (if (empty? invariants)
                (if (empty? broken-nodes) '() broken-nodes)
                (let ([result (check-invariant (first (first invariants))
                                               (second (first invariants)))])
                  (if (list? result)
                      (check-all-invariants-helper nonterminals-to-check
                                                   (rest invariants)
                                                   (append result broken-nodes))
                      (check-all-invariants-helper nonterminals-to-check
                                                   (rest invariants)
                                                   broken-nodes)))))]
         (check-all-invariants-helper nonterminals-to-check invariants '())))

;; levels -> (listof levels)
;; Creates a list containing the levels used for each graph generated
(define (create-list-of-levels levels)
  (local [(define (create-list-of-levels-helper lvls)
            (if (empty? lvls) '() (cons lvls (create-list-of-levels-helper (rest lvls)))))]
         (create-list-of-levels-helper (reverse levels))))

;; upper?
;; symbol -> Boolean
;; Purpose: Determines if a symbol is upper case
(define (upper? symbol)
  (char-upper-case? (string-ref (symbol->string symbol) 0)))

;; lower?
;; symbol -> Boolean
;; Purpose: Determines if a symbol is down case
(define (lower? symbol)
  (not (char-upper-case? (string-ref (symbol->string symbol) 0))))

;; create-edges
;; (listof level) <=> (listof (listof edge))
;; (listof symbol) -> (listof (listof edge))
;; Purpose: To create edges of the graph and group them by levels
(define (create-edges wd)
  (cond
    [(empty? wd) '()]
    [(= 1 (length wd)) (list (list (list (last (first wd)) null)))]
    [(= 2 (length wd))
     (if (equal? (length (first wd)) (length (second wd)))
         (list (list (list (last (first wd)) (last (second wd)))))
         (list (list (list (last (first wd)) EMP))))]
    [else
     (append (list (map (λ (x) (list (last (first wd)) x)) (take-right (second wd) 2)))
             (create-edges (rest wd)))]))

;; create-rules
;; (listof symbol) -> (listof string)
;; Purpose: To create rules for the informative message
(define (create-rules w-der)
  (cond
    [(empty? w-der) '()]
    [(= 1 (length w-der)) '()]
    [(= 2 (length w-der))
     (if (equal? (length (first w-der)) (length (second w-der)))
         (append (list (string-append (symbol->string (last (first w-der)))
                                      " → "
                                      (symbol->string (last (second w-der)))))
                 (create-rules (rest w-der)))
         (append
          (list (string-append (symbol->string (last (first w-der))) " → " (symbol->string EMP)))
          (create-rules (rest w-der))))]
    [else
     (append (list (string-append
                    (symbol->string (last (first w-der)))
                    " → "
                    (string-append (first (map symbol->string (take-right (second w-der) 2)))
                                   (second (map symbol->string (take-right (second w-der) 2))))))
             (create-rules (rest w-der)))]))

;; rename-edges
;; (listof level) -> (listof level)
;; Purpose: To rename the nonterminals that reoccur in extracted edges
(define (rename-edges exe)
  (define (rnm-lvl lvl acc)
    (cond
      [(empty? lvl) '()]
      [(= 1 (length lvl)) (list (list (first acc) (second (first lvl))) acc)]
      [(member (second (second lvl)) acc)
       (let ([new-symbol (generate-symbol (second (second lvl)) acc)])
         (list (list (list (first acc) (second (first lvl))) (list (first acc) new-symbol))
               (cons new-symbol acc)))]
      [else
       (list (list (list (first acc) (second (first lvl))) (list (first acc) (second (second lvl))))
             (cons (second (second lvl)) acc))]))
  (define (rnm-lvls exe accum)
    (if (empty? exe)
        '()
        (let* ([new-level-accum (rnm-lvl (first exe) accum)]
               [new-level (first new-level-accum)]
               [new-accum (second new-level-accum)])
          (cons new-level (rnm-lvls (rest exe) new-accum)))))
  (rnm-lvls exe (list (first (first (first exe))))))

;; rename-nodes
;; (listof level) -> (listof level)
;; Purpose: To rename the terminals that reoccur in extracted edges
(define (rename-nodes exe)
  (define (rnm-lvl lvl acc)
    (cond
      [(empty? lvl) '()]
      [(and (symbol? (first lvl)) (member (second lvl) acc))
       (let ([new-symbol (generate-symbol (second lvl) acc)])
         (list (list (first lvl) new-symbol) acc))]
      [(and (symbol? (first lvl)) (not (member (second lvl) acc)))
       (list (list (first lvl) (second lvl)) (cons (second lvl) acc))]
      [(member (second (first lvl)) acc)
       (let ([new-symbol (generate-symbol (second (first lvl)) acc)])
         (list (list (list (first (first lvl)) new-symbol) (second lvl)) (cons new-symbol acc)))]
      [else (list (list (first lvl) (second lvl)) (cons (second (first lvl)) acc))]))
  (define (rnm-lvls exe accum)
    (if (empty? exe)
        '()
        (let* ([new-level-accum (rnm-lvl (first exe) accum)]
               [new-level (first new-level-accum)]
               [new-accum (second new-level-accum)])
          (cons new-level (rnm-lvls (rest exe) new-accum)))))
  (if (= 1 (length exe)) exe (rnm-lvls exe (list (second (first (first exe)))))))

;; extract-nodes
;; (listof level) -> (listof node)
;; Purpose: To extract nodes from the list of edges - check if this is right
(define (extract-nodes loe)
  (remove-duplicates (flatten loe)))

;; dgrph (listof (list nonterminal predicate)) starting-nonterminal derivation-order
;; Purpose: Creates the list of broken invariants for a given dgrph
(define (create-invariant-nodes a-dgrph invariants root-node)
  (let* ([nodes (dgrph-nodes a-dgrph)]
         [levels (map reverse (dgrph-ad-levels a-dgrph))]
         [producing-nodes (get-producing-nodes (append* levels))]
         [invariant-nodes
          (let ([all-but-starting-nt
                 (append-map (lambda (lvl)
                               (let* ([nodes (map (lambda (edge) (second edge))
                                                  (filter (lambda (edge) (not (empty? edge))) lvl))])
                                 (filter (lambda (node) (member node producing-nodes)) nodes)))
                             levels)])
            (if (member root-node producing-nodes)
                (cons root-node all-but-starting-nt)
                all-but-starting-nt))]
         [broken-invariants
          (check-all-invariants (first (dgrph-p-yield-trees a-dgrph)) invariant-nodes invariants)])
    broken-invariants))

;; make-node-graph
;; graph lon -> graph
;; Purpose: To make a node graph
(define (make-node-graph graph
                         lon
                         hedge-nodes
                         yield-node
                         broken-invariants?
                         producing-nodes
                         has-invariant)
  (foldl (λ (state result)
           (add-node result
                     state
                     #:atb (hash 'color
                                 (cond
                                   [(member state hedge-nodes) HEDGE-COLOR]
                                   [(member state yield-node) YIELD-COLOR]
                                   [else 'black])
                                 'style
                                 (if (or (member state hedge-nodes)
                                         (member state yield-node))
                                     'dashed
                                     'solid)
                                 'fillcolor
                                 (cond
                                   [(not (member (undo-renaming state) has-invariant)) 'white]
                                   [(and (member (undo-renaming state) has-invariant)
                                         (not (member state producing-nodes)))
                                    'white]
                                   [(and (member (undo-renaming state) has-invariant)
                                         (member state producing-nodes)
                                         (member state broken-invariants?))
                                    INVARIANT-BROKEN-COLOR]
                                   [(and (member (undo-renaming state) has-invariant)
                                         (member state producing-nodes)
                                         (not (member state broken-invariants?)))
                                    INVARIANT-HOLDS-COLOR])
                                 'shape
                                 'circle
                                 'label
                                 (string->symbol (string (string-ref (symbol->string state) 0)))
                                 #;'penwidth
                                 #;(cond
                                   [(member state hedge-nodes) 3.0]
                                   [(member state yield-node) 3.0]
                                   [else 1.0])
                                 'fontcolor
                                 'black
                                 'font
                                 "Sans")))
         graph
         (reverse lon)))

;; make-edge-graph
;; graph (listof level) -> graph
;; Purpose: To make an edge graph
(define (make-edge-graph graph loe hedges)
  (let ([first-foldr
         (foldl (λ (rule result)
                  (if (empty? (first rule))
                      result
                      (add-edge result
                                ""
                                (first (first rule))
                                (second (first rule))
                                #:atb (hash 'fontsize
                                            FONT-SIZE
                                            'style
                                            (if (member (first rule) hedges)
                                                'dashed
                                                'solid)
                                            'color
                                            (if (member (first rule) hedges) HEDGE-COLOR 'black)))))
                graph
                (reverse loe))])
    (foldl (λ (rule result)
             (if (empty? (second rule))
                 result
                 (add-edge result
                           ""
                           (first (second rule))
                           (second (second rule))
                           #:atb (hash 'fontsize
                                       20
                                       'style
                                       (if (member (first rule) hedges)
                                                'dashed
                                                'solid)
                                       'color
                                       (if (member (first rule) hedges) HEDGE-COLOR 'black)))))
           first-foldr
           (reverse loe))))

(define (get-producing-nodes levels)
  (if (empty? levels)
      '()
      (if (empty? (first levels))
          (get-producing-nodes (rest levels))
          (cons (first (first levels)) (get-producing-nodes (rest levels))))))

;; create-graph-structs
;; dgprh -> img
;; Purpose: Creates the final graph structure that will be used to create the images in graphviz
(define (create-graph-structs a-dgrph invariants root-node)
  (let* ([nodes (append (filter lower? (dgrph-nodes a-dgrph)) (filter upper? (dgrph-nodes a-dgrph)))]
         [levels (map reverse (dgrph-ad-levels a-dgrph))]
         [reversed-levels (reverse levels)]
         [hedges (dgrph-hedges a-dgrph)]
         [hedge-nodes (map (λ (x) (if (empty? x) '() (second x))) hedges)]
         [yield-node (map (λ (x) (if (empty? x) '() (first x))) hedges)]
         [invariant-nts (map first invariants)]
         [producing-nodes (get-producing-nodes (append* levels))]
         [invariant-nodes
          (cons root-node
                (append-map (lambda (lvl)
                              (let* ([nodes (map (lambda (edge) (second edge))
                                                 (filter (lambda (edge) (not (empty? edge))) lvl))])
                                (filter (lambda (node) (member node producing-nodes)) nodes)))
                            levels))]
         [broken-invariant?
          (check-all-invariants (first (dgrph-p-yield-trees a-dgrph)) invariant-nodes invariants)])
    (make-edge-graph
     (make-node-graph (create-graph 'dgraph #:atb (hash 'rankdir "TB" 'font "Sans" 'ordering "in"))
                      nodes
                      hedge-nodes
                      yield-node
                      broken-invariant?
                      producing-nodes
                      invariant-nts)
     reversed-levels
     hedges)))

;; create-dgraphs
;; dgrph (listof dgrph) -> (listof dgrph)
;; Purpose: To create all the dgrphs for graph imgs
(define (create-dgrphs a-dgrph lod)
  (if (empty? (dgrph-up-levels a-dgrph))
      (cons a-dgrph lod)
      (let* ([new-up-levels (rest (dgrph-up-levels a-dgrph))]
             [new-ad-levels (cons (first (dgrph-up-levels a-dgrph)) (dgrph-ad-levels a-dgrph))]
             [new-nodes (extract-nodes new-ad-levels)]
             [new-hedges (first (dgrph-up-levels a-dgrph))]
             [new-up-rules (rest (dgrph-up-rules a-dgrph))]
             [new-p-rules (cons (first (dgrph-up-rules a-dgrph)) (dgrph-p-rules a-dgrph))]
             [new-up-yield-trees (rest (dgrph-up-yield-trees a-dgrph))]
             [new-p-yield-trees (cons (first (dgrph-up-yield-trees a-dgrph))
                                      (dgrph-p-yield-trees a-dgrph))])
        (create-dgrphs (dgrph new-up-levels
                              new-ad-levels
                              new-nodes
                              new-hedges
                              new-up-rules
                              new-p-rules
                              new-up-yield-trees
                              new-p-yield-trees)
                       (cons a-dgrph lod)))))

;; run function
(define (rg-viz rg word #:cpu-cores [cpu-cores #f] . invariants)
  (if (string? (grammar-derive rg word))
      (grammar-derive rg word)
      (let* ([derivation (rg-derive-with-rules rg word)]
             [w-der (map symbol->fsmlos
                         (map first (filter (λ (x) (not (equal? (first x) '->))) derivation)))]
             [rules (cons ""
                          (map (lambda (x)
                                 (string-append (symbol->string (first x))
                                                " → "
                                                (symbol->string (third x))))
                               (map second (rest derivation))))]
             [extracted-edges (create-edges w-der)]
             [renamed (rename-nodes (rename-edges extracted-edges))]
             [loe (map (λ (el) (if (symbol? (first el)) (list el '()) el)) renamed)]
             [loe-without-empty (map (λ (el) (if (symbol? (first el)) (list el) el)) renamed)]
             [yield-trees (map create-yield-tree
                               (map reverse (create-list-of-levels loe-without-empty)))]
             [dgraph (dgrph loe
                            '()
                            '()
                            '()
                            (rest rules)
                            (list (first rules))
                            (reverse yield-trees)
                            (list (tree (grammar-start rg) '())))]
             [lod (reverse (create-dgrphs dgraph '()))]
             [broken-invariants
              (if (empty? invariants)
                  'NO-INV
                  (list->zipper
                   (map (lambda (a-dgrph)
                          (remove-duplicates
                           (map undo-renaming
                                (create-invariant-nodes a-dgrph invariants (grammar-start rg)))))
                        lod)))]
             [graphs (map (lambda (dgrph) (create-graph-structs dgrph invariants (grammar-start rg)))
                          lod)])
        (init-viz rg word w-der rules graphs broken-invariants)
        )))
(rg-viz even-bs-odd-as '(a a a a a b b b b a a a a a a a a a a a b b b b a a a a a a a a a a a b b b b a a a a a a))

#;(profile (rg-viz even-bs-odd-as '(a a a a a b b b b a a a a a a a a a a a b b b b a a a a a a a a a a a b b b b a a a a a a))
         #:svg-path "profile.svg"
         #:preview? #t)
(define G (make-rg '(S) '(a b) `((S ,ARROW ,EMP) (S ,ARROW aS)) 'S))
