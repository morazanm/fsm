#lang racket
(require "../fsm-gviz/private/lib.rkt"
         "../fsm-core/private/cfg.rkt"
         "../fsm-core/interface.rkt"
         "../fsm-core/private/constants.rkt"
         "../fsm-core/private/misc.rkt"
         "circular-queue-treelist.rkt"
         "grammar-viz.rkt"
         "zipper.rkt"
         "cfg-derive-rightmost.rkt"
         "cfg-derive-leftmost.rkt"
         "cfg-derive-level-rightmost.rkt"
         "cfg-derive-level-leftmost.rkt"
         racket/treelist
         "yield-struct.rkt")
(provide cfg-viz)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define even-bs-odd-as
  (make-cfg '(S A B C)
            '(a b)
            `((S ,ARROW aA) (S ,ARROW bB)
                            (S ,ARROW a)
                            (A ,ARROW aS)
                            (A ,ARROW bC)
                            (B ,ARROW aC)
                            (B ,ARROW bS)
                            (C ,ARROW aB)
                            (C ,ARROW bA)
                            (C ,ARROW b))
            'S))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define HEDGE-COLOR 'violet)
(define YIELD-COLOR 'orange)
(define INVARIANT-HOLDS-COLOR 'green)
(define INVARIANT-BROKEN-COLOR 'red)
(define FONT-SIZE 20)
(define TAPE-SIZE 42)

;; dgrph is a structure that has
;; up-levels - unprocessed levels
;; ad-levels - levels added to the graph
;; nodes - nodes in the graph
;; hedges - highlighted edges of the graphs
;; up-rules - unprocessed grammar rules
;; p-rules - processed grammar rules
(struct dgrph (up-levels ad-levels nodes hedges up-rules p-rules up-yield-trees p-yield-trees))

;; tree Any -> (U #f tree)
;; Finds the search value within the tree using a depth first search
(define (dfs node search-val)
  (if (equal? (tree-value node) search-val)
      node
      (ormap (lambda (node) (dfs node search-val)) (tree-subtrees node))))

;; A tree has a value and subtrees
;; A value is Any
;; A subtree is a listof Any
(struct tree (value [subtrees #:mutable]) #:transparent)

;; levels -> tree
;; Creates a tree structure from the levels
(define (create-yield-tree levels)
  (foldl (lambda (val accum)
           (begin
             (set-tree-subtrees! (dfs accum (first (first val)))
                                 (map (lambda (edge) (tree (second edge) '())) val))
             accum))
         (tree 'S '())
         levels))

;; Symbol -> Symbol
;; Removes all numbers from the symbol (that were originally added for differentiating in graphviz)
(define (undo-renaming symb)
  (string->symbol (list->string (filter (lambda (x)
                                          (not (or (equal? #\0 x)
                                                   (equal? #\1 x)
                                                   (equal? #\2 x)
                                                   (equal? #\3 x)
                                                   (equal? #\4 x)
                                                   (equal? #\5 x)
                                                   (equal? #\6 x)
                                                   (equal? #\7 x)
                                                   (equal? #\8 x)
                                                   (equal? #\9 x))))
                                        (string->list (symbol->string symb))))))

;; tree -> listof Symbol
;; Accumulates all of the leave nodes in order (producing the yield of the tree)
(define (get-yield subtree)
  (local [;; lower?
          ;; symbol -> Boolean
          ;; Purpose: Determines if a symbol is down case
          (define (lower? symbol)
            (not (char-upper-case? (string-ref (symbol->string symbol) 0))))
          (define subtree-copy (struct-copy tree subtree))
          (define (get-yield-helper subtree)
            (foldl (lambda (node yield)
                     (cond
                       [(equal? (undo-renaming (tree-value node)) EMP) yield]
                       [(empty? (tree-subtrees node)) (append yield (list (tree-value node)))]
                       [else (append yield (get-yield-helper node))]))
                   '()
                   (tree-subtrees subtree)))]
         (filter (lambda (node) (lower? node))
                 (foldl (lambda (node yield)
                          (cond
                            [(equal? (undo-renaming (tree-value node)) EMP) yield]
                            [(empty? (tree-subtrees node)) (append yield (list (tree-value node)))]
                            [else (append yield (get-yield-helper node))]))
                        '()
                        (tree-subtrees subtree)))))

;; tree invariant-function -> (U boolean Symbol)
;; Evaluates the invariant function given to us by the user on the current yield
;; generated by its respective nonterminal
(define (invariant-holds? subtree invar-func)
  (invar-func (map undo-renaming (get-yield subtree))))

;; tree (listof Symbol) (listof (list Symbol ((listof Symbol) -> (U boolean Symbol)) -> (U boolean Symbol)
;; Checks all invariants against all of their respective nodes
(define (check-all-invariants tree nonterminals-to-check invariants)
  (local [(define (check-invariant invariant-nt invariant-func)
            (local [(define (find-all-invariant-nodes nts)
                      (if (empty? nts)
                          '()
                          (if (equal? invariant-nt (undo-renaming (first nts)))
                              (cons (first nts) (find-all-invariant-nodes (rest nts)))
                              (find-all-invariant-nodes (rest nts)))))
                    (define (check-all-invariant-nodes nonterminals invar-func broken-nodes)
                      (if (empty? nonterminals)
                          (if (empty? broken-nodes) #t broken-nodes)
                          (if (invariant-holds? (dfs tree (first nonterminals)) invar-func)
                              (check-all-invariant-nodes (rest nonterminals) invar-func broken-nodes)
                              (check-all-invariant-nodes (rest nonterminals)
                                                         invar-func
                                                         (cons (first nonterminals) broken-nodes)))))]
                   (check-all-invariant-nodes (find-all-invariant-nodes nonterminals-to-check)
                                              invariant-func
                                              '())))
          (define (check-all-invariants-helper nonterminals-to-check invariants broken-nodes)
            (if (empty? invariants)
                (if (empty? broken-nodes) '() broken-nodes)
                (let ([result (check-invariant (first (first invariants))
                                               (second (first invariants)))])
                  (if (list? result)
                      (check-all-invariants-helper nonterminals-to-check
                                                   (rest invariants)
                                                   (append result broken-nodes))
                      (check-all-invariants-helper nonterminals-to-check
                                                   (rest invariants)
                                                   broken-nodes)))))]
         (check-all-invariants-helper nonterminals-to-check invariants '())))

;; levels -> (listof levels)
;; Purpose: creates a list containing the levels used for each graph generated
(define (create-list-of-levels levels)
  (local [;; levels -> (listof levels)
          ;; Purpose: creates a list containing the levels used for each graph generated in reverse
          (define (create-list-of-levels-helper lvls)
            (if (empty? lvls) '() (cons lvls (create-list-of-levels-helper (rest lvls)))))]
         (create-list-of-levels-helper (reverse levels))))

;; nonterminal?
;; symbol -> Boolean
;; Purpose: Determines if the first character within the symbol is a uppercase letter,
;; and hence a nonterminal
(define (nonterminal? symb)
  (char-upper-case? (first (string->list (symbol->string symb)))))

;; find-leftmost-nt
;; (listof symbol) -> (U #f Symbol)
;; Purpose: If it exists, returns the leftmost-nt in the state given. Otherwise, returns false
(define (find-leftmost-nt state)
  (if (empty? state)
      #f
      (if (list? state)
          (if (nonterminal? (first state)) (first state) (find-leftmost-nt (rest state)))
          (if (nonterminal? state) state #f))))

;; (listof symbol) -> (U #f Symbol)
;; If it exists, returns the leftmost-nt in the state given. Otherwise, returns false
(define (find-rightmost-nt state)
  (if (list? state) (find-leftmost-nt (reverse state)) (find-leftmost-nt (list state))))

;; create-rules
;; (listof symbol) -> (listof string)
;; Purpose: To create the rules for leftmost derivation
(define (create-rules-leftmost w-der)
  (cond
    [(empty? w-der) '()]
    [(= 1 (length w-der)) '()]
    [else
     (append (list (string-append (symbol->string (find-leftmost-nt (first (first w-der))))
                                  " → "
                                  (string-join (map symbol->string (second (first w-der))))))
             (create-rules-leftmost (rest w-der)))]))

;; create-rules
;; (listof symbol) -> (listof string)
;; Purpose: To create the rules for rightmost derivation
(define (create-rules-rightmost w-der)
  (cond
    [(empty? w-der) '()]
    [(= 1 (length w-der)) '()]
    [else
     (append (list (string-append (symbol->string (find-rightmost-nt (first (first w-der))))
                                  " → "
                                  (string-join (map symbol->string (second (first w-der))))))
             (create-rules-rightmost (rest w-der)))]))

;; extract-nodes
;; (listof level) -> (listof node)
;; Purpose: To extract nodes from the list of edges - check if this is right
(define (extract-nodes loe)
  (remove-duplicates (flatten loe)))

;; make-node-graph
;; graph lon -> graph
;; Purpose: To make a node graph
(define (make-node-graph graph
                         lon
                         hedge-nodes
                         yield-node
                         broken-invariants?
                         producing-nodes
                         has-invariant)
  (foldl (λ (state result)
           (add-node result
                     state
                     #:atb (hash 'color
                                 (cond
                                   [(member state hedge-nodes) HEDGE-COLOR]
                                   [(member state yield-node) YIELD-COLOR]
                                   [else 'black])
                                 'style
                                 'filled
                                 'fillcolor
                                 (cond
                                   [(not (member (undo-renaming state) has-invariant)) 'white]
                                   [(and (member (undo-renaming state) has-invariant)
                                         (not (member state producing-nodes)))
                                    'white]
                                   [(and (member (undo-renaming state) has-invariant)
                                         (member state producing-nodes)
                                         (member state broken-invariants?))
                                    INVARIANT-BROKEN-COLOR]
                                   [(and (member (undo-renaming state) has-invariant)
                                         (member state producing-nodes)
                                         (not (member state broken-invariants?)))
                                    INVARIANT-HOLDS-COLOR])
                                 'shape
                                 'circle
                                 'label
                                 (string->symbol (string (string-ref (symbol->string state) 0)))
                                 'fontcolor
                                 'black
                                 'font
                                 "Sans")))
         graph
         (reverse lon)))

(define (make-invis-edges graph lvl)
  (if (= (length lvl) 1)
      graph
      (make-invis-edges
       (add-edge graph "" (first lvl) (second lvl) #:atb (hash 'style 'invisible 'arrowhead 'none))
       (rest lvl))))

;; graph (listof edges) -> graph
;; Creates invisible edges so that ordering of the yield nodes is always maintained
(define (make-invisible-edge-graph graph rank-node-lvls)
  (foldr (lambda (lvls accum) (make-invis-edges accum lvls)) graph rank-node-lvls))

;; make-edge-graph
;; graph (listof level) -> graph
;; Purpose: To make an edge graph
(define (make-edge-graph graph loe hedges)
  (foldl (lambda (rules result)
           (if (empty? (first rules))
               result
               (foldl (lambda (rule result)
                        (add-edge result
                                  ""
                                  (first rule)
                                  (second rule)
                                  #:atb (hash 'fontsize
                                              FONT-SIZE
                                              'style
                                              'solid
                                              'color
                                              (if (member rule hedges) HEDGE-COLOR 'black))))
                      result
                      rules)))
         graph
         (reverse loe)))

;; create-graph-structs
;; dgprh -> img
;; Purpose: Creates the final graph structure that will be used to create the images in graphviz
(define (create-graph-structs a-dgrph invariants derv-order root-node rank-node-lvls)
  (let* ([nodes (dgrph-nodes a-dgrph)]
         [levels (map reverse (dgrph-ad-levels a-dgrph))]
         [reversed-levels (reverse levels)]
         [hedges (dgrph-hedges a-dgrph)]
         [invariant-nts (map first invariants)]
         [producing-nodes (map (lambda (edge) (first edge)) (append* levels))]
         [invariant-nodes
          (cons root-node
                (append-map
                 (lambda (lvl)
                   (let* ([nodes (map (lambda (edge) (second edge)) lvl)]
                          [invar-nodes (filter (lambda (node) (member node producing-nodes)) nodes)])
                     (cond
                       [(equal? derv-order 'left) (reverse invar-nodes)]
                       [(equal? derv-order 'right) invar-nodes]
                       [else invar-nodes])))
                 levels))]
         [broken-invariant?
          (check-all-invariants (first (dgrph-p-yield-trees a-dgrph)) invariant-nodes invariants)]
         [hedge-nodes (map (λ (x) (if (empty? x) '() (second x))) hedges)]
         [yield-node (map (λ (x) (if (empty? x) '() (first x))) hedges)])
    (make-invisible-edge-graph
     (make-edge-graph
      (make-node-graph (create-graph 'dgraph #:atb (hash 'rankdir "TB" 'font "Sans" 'ordering "in"))
                       nodes
                       hedge-nodes
                       yield-node
                       broken-invariant?
                       producing-nodes
                       invariant-nts)
      reversed-levels
      hedges)
     rank-node-lvls)))

;; dgrph (listof (list nonterminal predicate)) starting-nonterminal derivation-order
;; Purpose: Creates the list of broken invariants for a given dgrph
(define (create-invariant-nodes a-dgrph invariants root-node derv-order)
  (let* ([nodes (dgrph-nodes a-dgrph)]
         [levels (map reverse (dgrph-ad-levels a-dgrph))]
         [producing-nodes (map (lambda (edge) (first edge)) (append* levels))]
         [invariant-nodes
          (let ([all-but-starting-nt
                 (append-map
                  (lambda (lvl)
                    (let* ([nodes (map (lambda (edge) (second edge)) lvl)]
                           [invar-nodes (filter (lambda (node) (member node producing-nodes)) nodes)])
                      (cond
                        [(equal? derv-order 'left) (reverse invar-nodes)]
                        [(equal? derv-order 'right) invar-nodes]
                        [(equal? derv-order 'level-left) (reverse invar-nodes)]
                        [(equal? derv-order 'level-right) invar-nodes])))
                  levels)])
            (if (member root-node producing-nodes)
                (cons root-node all-but-starting-nt)
                all-but-starting-nt))]
         [broken-invariants
          (check-all-invariants (first (dgrph-p-yield-trees a-dgrph)) invariant-nodes invariants)])
    broken-invariants))

;; create-dgraphs
;; dgrph (listof dgrph) -> (listof dgrph)
;; Purpose: To create all the dgrphs for graph imgs
(define (create-dgrphs a-dgrph lod)
  (if (empty? (dgrph-up-levels a-dgrph))
      (cons a-dgrph lod)
      (let* ([new-up-levels (rest (dgrph-up-levels a-dgrph))]
             [new-ad-levels (cons (first (dgrph-up-levels a-dgrph)) (dgrph-ad-levels a-dgrph))]
             [new-nodes (extract-nodes new-ad-levels)]
             [new-hedges (first (dgrph-up-levels a-dgrph))]
             [new-up-rules (rest (dgrph-up-rules a-dgrph))]
             [new-p-rules (cons (first (dgrph-up-rules a-dgrph)) (dgrph-p-rules a-dgrph))]
             [new-up-yield-trees (rest (dgrph-up-yield-trees a-dgrph))]
             [new-p-yield-trees (cons (first (dgrph-up-yield-trees a-dgrph))
                                      (dgrph-p-yield-trees a-dgrph))])
        (create-dgrphs (dgrph new-up-levels
                              new-ad-levels
                              new-nodes
                              new-hedges
                              new-up-rules
                              new-p-rules
                              new-up-yield-trees
                              new-p-yield-trees)
                       (cons a-dgrph lod)))))

;; w-der
;; derivation -> derivation-list
;; Purpose: To turn the derivation into a list
(define (w-der-with-rules derivation)
  (map (lambda (state) (list (symbol->fsmlos (first state)) (symbol->fsmlos (second state))))
       (filter (λ (x) (not (equal? x '->))) derivation)))

;; rename-symb
;; MutableHashTable Symbol -> Symbol
;; Purpose:  Returns a unique version of the symbol given (via the addition of
;; a previously unused number to the end of it)
(define (rename-symb hashtable nt)
  (let ([result (hash-ref hashtable nt #f)])
    (if result
        (begin
          (hash-set! hashtable nt (add1 result))
          (string->symbol (format "~s~s" nt (add1 result))))
        (begin
          (hash-set! hashtable nt 0)
          (string->symbol (format "~s0" nt))))))

;; generate-levels-list-helper
;; (listof symbol) (listof (listof symbol)) (listof (listof symbol)) MutableHashTable ->
;; (listof symbol) (U #f symbol)) -> (listof (listof (listof symbol)))
(define (generate-levels-list-helper current-state rules prev-states used-names find-nt-func)
  ;; The list of generated rules used contains an empty list denoting no more rules, hence
  ;; the need to call "first" first
  (if (empty? (first rules))
      ;; If theres no more rules to apply than computation is done
      '()
      (let ([current-nt (find-nt-func current-state)])
        (if (boolean? current-nt)
            ;; If its fails to find a nonterminal in the current state, attempt to go back up
            ;; the stack to a previous state
            (if (empty? prev-states)
                ;; If there are no more previous states, than the computation is done
                '()
                (let* ([prev-state (first prev-states)]
                       [prev-current-nt (find-nt-func prev-state)]
                       ;; Need to remove the leftmost-nt from the previous state since we just went
                       ;; down its respective path
                       ;; when we call the function again with it removed, the next nt will be processed
                       [updated-states (filter (lambda (x) (not (eq? prev-current-nt x)))
                                               prev-state)])
                  ;; Don't reduce the number of rules here since one was not sucessfully applied, only
                  ;; remove the state we popped off the stack
                  (generate-levels-list-helper updated-states
                                               rules
                                               (rest prev-states)
                                               used-names
                                               find-nt-func)))
            (local
             [;; Just sticks a number after the symbol itself, uses a hash table to keep track of what numbers
              ;; were already used for a specific symbol
              (define renamed-states (map (lambda (st) (rename-symb used-names st)) (first rules)))
              ;; Creates a new level by taking the current rule that is meant to be applied at this point of
              ;; the derivation
              ;; and creating an edge between each of the elements within and the current nonterminal being
              ;;processed
              (define (new-level start)
                (map (lambda (st) (list start st)) renamed-states))]
             (cons (new-level current-nt)
                   (generate-levels-list-helper renamed-states
                                                (rest rules)
                                                (cons current-state prev-states)
                                                used-names
                                                find-nt-func)))))))

;; list any -> list
;; Purpose: Returns the list up until and excluding the value given
(define (take-until lst val)
  (if (eq? (first lst) val) '() (cons (first lst) (take-until (rest lst) val))))

;; generate-levels-list
;; (listof symbol) (listof (listof symbol)) (listof (listof symbol)) MutableHashTable (U 'left 'right 'level) ->
;; (listof (listof (listof symbol)))
;; Purpose: Generates levels from rules
(define (generate-levels-list current-state rules prev-states used-names derv-type)
  (cond
    [(eq? derv-type 'left)
     (generate-levels-list-helper current-state rules prev-states used-names find-leftmost-nt)]
    [(eq? derv-type 'right)
     (generate-levels-list-helper current-state rules prev-states used-names find-rightmost-nt)]))

;; (listof symbol) -> symbol
;; Purpose: Returns the leftmost nonterminal held within the list of symbols
(define (get-leftmost-nt st)
  (cond
    [(empty? st) #f]
    [(nonterminal? (first st)) (first st)]
    [else (get-leftmost-nt (cdr st))]))

;; (listof symbol) -> symbol
;; Purpose: Returns the rightmost nonterminal held within the list of symbols
(define (get-rightmost-nt st)
  (get-leftmost-nt (reverse st)))

;; (listof symbol) (listof symbol) (listof (listof symbol)) mutable-hashtable ((listof symbol) -> symbol) symbol
;; Purpose: Generates the levels used by graphviz to produce the images for the visualization
(define (generate-levels-bfs-list-helper unprocessed-yield
                                         processed-yield
                                         rules
                                         used-names
                                         find-nt-func
                                         derv-type)
  (if (empty? rules)
      '()
      (let ([current-nt (find-nt-func unprocessed-yield)])
        (if (false? current-nt)
            (generate-levels-bfs-list-helper processed-yield
                                             '()
                                             rules
                                             used-names
                                             find-nt-func
                                             derv-type)
            (local
             [(define renamed-states (map (lambda (st) (rename-symb used-names st)) (first rules)))
              (define (new-level start)
                (map (lambda (st) (list start st)) renamed-states))]
             (cons (new-level current-nt)
                   (generate-levels-bfs-list-helper
                    (if (eq? derv-type 'level-left)
                        (rest (member current-nt unprocessed-yield))
                        (take-until unprocessed-yield current-nt))
                    (if (eq? derv-type 'level-left)
                        (append (if (list? processed-yield) processed-yield (list processed-yield))
                                (if (list? renamed-states) renamed-states (list renamed-states)))
                        (append (if (list? renamed-states) renamed-states (list renamed-states))
                                (if (list? processed-yield) processed-yield (list processed-yield))))
                    (rest rules)
                    used-names
                    find-nt-func
                    derv-type)))))))

(define (treelist-insert-list tl i lst)
  (if (empty? lst) tl (treelist-insert-list (treelist-insert tl i (first lst)) (add1 i) (rest lst))))

(define (get-first-nt st alphabet-ht)
  (define (get-first-nt-helper i)
    (cond
      [(= i (treelist-length (yield-state st))) (list #f)]
      [(not (hash-ref alphabet-ht (undo-renaming (treelist-ref (yield-state st) i)) #f))
       (list (treelist-ref (yield-state st) i) i)]
      [else (get-first-nt-helper (add1 i))]))
  (get-first-nt-helper (yield-up st)))

(define (generate-levels-bfs-leftmost curr-yield rules used-names alphabet-ht)
  (if (empty? (first rules))
      '()
      ;; Going to make this function return (list nt idx)
      (let ([current-nt (get-first-nt curr-yield alphabet-ht)])
        (if (false? (first current-nt))
            (generate-levels-bfs-leftmost (yield (yield-state curr-yield) 0)
                                          rules
                                          used-names
                                          alphabet-ht)
            (let ([renamed-chars (map (lambda (word-char) (rename-symb used-names word-char))
                                      (third (first rules)))])
              (cons (map (lambda (word-char) (list (first current-nt) word-char)) renamed-chars)
                    (generate-levels-bfs-leftmost
                     (yield (treelist-insert-list
                             (treelist-delete (yield-state curr-yield) (second current-nt))
                             (second current-nt)
                             (filter (lambda (x) (not (equal? EMP (undo-renaming x)))) renamed-chars))
                            (+ (second current-nt) (length renamed-chars)))
                     (rest rules)
                     used-names
                     alphabet-ht)))))))

;; (listof symbol) -> symbol
;; Purpose: Returns rightmost nonterminal
(define (get-last-nt-helper st i alphabet-ht)
  (if (= i -1)
      (list #f)
      (if (not (hash-ref alphabet-ht (undo-renaming (treelist-ref (yield-state st) i)) #f))
          (list (treelist-ref (yield-state st) i) i)
          (get-last-nt-helper st (sub1 i) alphabet-ht))))

;; (listof symbol) -> symbol
;; Purpose: Returns rightmost nonterminal
(define (get-last-nt st alphabet-ht)
  (get-last-nt-helper st (yield-up st) alphabet-ht))

(define (generate-levels-bfs-rightmost curr-yield rules used-names alphabet-ht)
  (if (empty? (first rules))
      '()
      ;; Going to make this function return (list nt idx)
      (let ([current-nt (get-last-nt curr-yield alphabet-ht)])
        (if (false? (first current-nt))
            (generate-levels-bfs-rightmost (yield (yield-state curr-yield)
                                                  (sub1 (treelist-length (yield-state curr-yield))))
                                           rules
                                           used-names
                                           alphabet-ht)
            (let ([renamed-chars (map (lambda (word-char) (rename-symb used-names word-char))
                                      (third (first rules)))])
              (cons (map (lambda (word-char) (list (first current-nt) word-char)) renamed-chars)
                    (generate-levels-bfs-rightmost
                     (yield (treelist-insert-list
                             (treelist-delete (yield-state curr-yield) (second current-nt))
                             (second current-nt)
                             (filter (lambda (x) (not (equal? EMP (undo-renaming x)))) renamed-chars))
                            (sub1 (second current-nt)))
                     (rest rules)
                     used-names
                     alphabet-ht)))))))

;; (listof symbol) (listof symbol) (listof (listof symbol)) mutable-hashtable symbol
;; Purpose: Generates the levels used by graphviz to produce the images for the visualization
(define (generate-levels-bfs-list unprocessed-yield processed-yield rules used-names derv-type)
  (cond
    [(eq? derv-type 'level-left)
     (generate-levels-bfs-list-helper unprocessed-yield
                                      processed-yield
                                      rules
                                      used-names
                                      get-leftmost-nt
                                      derv-type)]
    [(eq? derv-type 'level-right)
     (generate-levels-bfs-list-helper unprocessed-yield
                                      processed-yield
                                      rules
                                      used-names
                                      get-rightmost-nt
                                      derv-type)]))

;; w-der -> (listof rules)
;; Purpose: This is just taking the list received from the new w-der and new cfg-derive and moving the rules like such:
;; '( ((S) ()) ((AbA) (AbA)) )
;; where the rule applied was next to where it was applied, to:
;; '( ((S) (AbA)) ((AbA) (AaAbA)) )
;; now the rule is next to where it will be applied
(define (move-rule-applications-in-list lst)
  (if (= (length lst) 1)
      (list (list (first (first lst)) '()))
      (cons (list (first (first lst)) (second (second lst)))
            (move-rule-applications-in-list (rest lst)))))

;; list-of-states
;; derivation-with-rules -> (listof rules)
;; Purpose: Separates the list of states from their rule applications in the list generated by w-der
(define (list-of-states lst)
  (map (lambda (x) (first x)) lst))

;; Separates the list of rules from their respective states in the list generated by w-der
;; derivation-with-rules -> derivation
(define (list-of-rules lst)
  (map (lambda (x) (second x)) lst))

;; (listof symbol) (listof yield) -> w-der
;; Purpose: Converts a yield derivation into the form of a word derivation that the viz expects
(define (convert-yield-deriv-to-word-deriv input-word yield-deriv)
  (remove-duplicates (map (lambda (x) (treelist->list (yield-state (first x)))) yield-deriv)))

;; (listof yield) -> (listof symbol)
;; Purpose: Creates a list of rules for a leftmost bfs derivation that are used in the visualization
(define (create-rules-levels-leftmost yield-deriv)
  (cond
    [(empty? yield-deriv) '()]
    [(= 1 (length yield-deriv)) '()]
    [(symbol? (get-leftmost-nt (yield-up (first (first yield-deriv)))))
     (append
      (list (string-append (symbol->string (get-leftmost-nt (yield-up (first (first yield-deriv)))))
                           " → "
                           (string-join (map symbol->string (second (first yield-deriv))))))
      (create-rules-levels-leftmost (rest yield-deriv)))]
    [else (create-rules-levels-leftmost (rest yield-deriv))]))

;; (listof yield) -> (listof symbol)
;; Purpose: Creates a list of rules for a rightmost bfs derivation that are used in the visualization
(define (create-rules-levels-rightmost yield-deriv)
  (cond
    [(empty? yield-deriv) '()]
    [(= 1 (length yield-deriv)) '()]
    [(not (empty? (yield-up (first (first yield-deriv)))))
     (append
      (list (string-append (symbol->string (get-rightmost-nt (yield-up (first (first yield-deriv)))))
                           " → "
                           (string-join (map symbol->string (second (first yield-deriv))))))
      (create-rules-levels-rightmost (rest yield-deriv)))]
    [(empty? (yield-up (first (first yield-deriv))))
     (create-rules-levels-rightmost (rest yield-deriv))]))

(define (get-level-rightmost-order yt)
  (define (get-level-rightmost-order-helper q accum)
    (if (qempty? q)
        accum
        (if (empty? (tree-subtrees (qpeek q)))
            (if (equal? (tree-value (qpeek q)) EMP)
                (get-level-rightmost-order-helper (dequeue! q) accum)
                (get-level-rightmost-order-helper (dequeue! q)
                                                  (append (list (tree-value (qpeek q))) accum)))
            (get-level-rightmost-order-helper (foldr (lambda (val q-accum) (enqueue! q-accum val))
                                                     (dequeue! q)
                                                     (tree-subtrees (qpeek q)))
                                              (append (list (tree-value (qpeek q))) accum)))))
  (if (empty? (tree-subtrees yt))
      (list (tree-value yt))
      (get-level-rightmost-order-helper
       (foldr (lambda (val q-accum) (enqueue! q-accum val)) (make-queue) (tree-subtrees yt))
       (list (tree-value yt)))))

(define (get-level-leftmost-order yt)
  (define (get-level-leftmost-order-helper q accum)
    (if (qempty? q)
        accum
        (if (empty? (tree-subtrees (qpeek q)))
            (if (equal? (tree-value (qpeek q)) EMP)
                (get-level-leftmost-order-helper (dequeue! q) accum)
                (get-level-leftmost-order-helper (dequeue! q)
                                                 (append accum (list (tree-value (qpeek q))))))
            (get-level-leftmost-order-helper (foldl (lambda (val q-accum) (enqueue! q-accum val))
                                                    (dequeue! q)
                                                    (tree-subtrees (qpeek q)))
                                             (append accum (list (tree-value (qpeek q))))))))
  (if (empty? (tree-subtrees yt))
      (list (tree-value yt))
      (get-level-leftmost-order-helper
       (foldl (lambda (val q-accum) (enqueue! q-accum val)) (make-queue) (tree-subtrees yt))
       (list (tree-value yt)))))

(define (get-leftmost-order-helper subtrees)
  (if (empty? subtrees)
      '()
      (append (get-leftmost-order (first subtrees)) (get-leftmost-order-helper (rest subtrees)))))

(define (get-leftmost-order yt)
  (if (empty? (tree-subtrees yt))
      (if (eq? (tree-value yt) EMP) '() (list (tree-value yt)))
      (append (list (tree-value yt)) (get-leftmost-order-helper (tree-subtrees yt)))))

(define (get-rightmost-order-helper subtrees)
  (if (empty? subtrees)
      '()
      (append (get-rightmost-order (last subtrees))
              (get-rightmost-order-helper (drop-right subtrees 1)))))

(define (get-rightmost-order yt)
  (if (empty? (tree-subtrees yt))
      (if (eq? (tree-value yt) EMP) '() (list (tree-value yt)))
      (append (list (tree-value yt)) (get-rightmost-order-helper (tree-subtrees yt)))))

(define (get-ordered-invariant-nodes ordered-nodes invar-nodes)
  (define (get-ordered-invariant-nodes-helper ordered-nodes invar-nodes)
    (filter (lambda (node) (member node invar-nodes)) ordered-nodes))
  (if (empty? ordered-nodes)
      '()
      (cons (get-ordered-invariant-nodes-helper (first ordered-nodes) (first invar-nodes))
            (get-ordered-invariant-nodes (rest ordered-nodes) (rest invar-nodes)))))

(define (accumulate-previous-ranks rank-node-lst accum)
  (if (empty? rank-node-lst)
      '()
      (let ([new-accum (append accum (list (first rank-node-lst)))])
        (cons new-accum (accumulate-previous-ranks (rest rank-node-lst) new-accum)))))

(define (remove-duplicate-yields yields)
  (define visited (make-hash))
  (define (remove-duplicate-yields-helper yields accum)
    (if (empty? yields)
        accum
        (if (false? (hash-ref visited (yield-state (first (first yields))) #f))
            (begin
              (hash-set! visited (yield-state (first (first yields))) #t)
              (remove-duplicate-yields-helper (rest yields) (cons (first yields) accum)))
            (remove-duplicate-yields-helper (rest yields) accum))))
  (reverse (remove-duplicate-yields-helper yields '())))

;; cfg-viz
;; cfg (listof Symbol) Symbol . (listof (list Symbol ((listof Symbol) -> boolean))) -> visualization
;; Starts the visualization
(define (cfg-viz cfg word [derv-type 'left] . invariants)
  (if (or (eq? derv-type 'left) (eq? derv-type 'right))
      (let ([derivation (if (eq? derv-type 'left)
                            (cfg-derive-leftmost cfg word)
                            (cfg-derive-rightmost cfg word))])
        (if (string? derivation)
            derivation
            (let* ([der-with-rules (w-der-with-rules derivation)]
                   [rules
                    (cons ""
                          (cond
                            [(eq? derv-type 'left)
                             (create-rules-leftmost (move-rule-applications-in-list der-with-rules))]
                            [(eq? derv-type 'right)
                             (create-rules-rightmost (move-rule-applications-in-list
                                                      der-with-rules))]))]
                   [w-der (list-of-states der-with-rules)]
                   [renamed (generate-levels-list
                             (first (first (first der-with-rules)))
                             (list-of-rules (move-rule-applications-in-list der-with-rules))
                             '()
                             (make-hash)
                             derv-type)]

                   ;(rank-node-lvls (cons (list 'S) (map (lambda (x) (map (lambda (y) (second y)) x)) renamed)))
                   [rank-node-lvls (cons (list (list 'S))
                                         (accumulate-previous-ranks
                                          (map (lambda (x) (map (lambda (y) (second y)) x)) renamed)
                                          (list (list 'S))))]
                   [yield-trees (map create-yield-tree (map reverse (create-list-of-levels renamed)))]
                   [dgraph (dgrph renamed
                                  '()
                                  '()
                                  '()
                                  (rest rules)
                                  (list (first rules))
                                  (reverse yield-trees)
                                  (list (tree (grammar-start cfg) '())))]
                   [lod (reverse (create-dgrphs dgraph '()))]
                   [invar-nodes
                    (map (lambda (a-dgrph)
                           (create-invariant-nodes a-dgrph invariants (grammar-start cfg) derv-type))
                         lod)]
                   [ordered-nodes
                    (reverse (map (if (eq? derv-type 'left) get-leftmost-order get-rightmost-order)
                                  yield-trees))]
                   [broken-invariants (list->zipper (cons '()
                                                          (map (lambda (lst) (map undo-renaming lst))
                                                               (map reverse
                                                                    (rest (get-ordered-invariant-nodes
                                                                           ordered-nodes
                                                                           invar-nodes))))))]
                   [graphs (map (lambda (dgrph node-lvls)
                                  (create-graph-structs dgrph
                                                        invariants
                                                        derv-type
                                                        (grammar-start cfg)
                                                        node-lvls))
                                lod
                                rank-node-lvls)])
              (init-viz cfg
                        word
                        w-der
                        rules
                        graphs
                        broken-invariants
                        #:special-graphs? 'cfg
                        #:rank-node-lst rank-node-lvls))))
      (let ([derivation (if (equal? derv-type 'level-left)
                            (cfg-derive-level-leftmost cfg word)
                            (cfg-derive-level-rightmost cfg word))])
        (if (string? derivation)
            derivation
            (let* ([rules (append (rest (map (lambda (x) (second x))
                                             (remove-duplicate-yields derivation)))
                                  (list '()))]
                   [string-rules
                    (drop-right
                     (cons ""
                           (map (lambda (x)
                                  (if (empty? x)
                                      ""
                                      (string-join (list (symbol->string (first x))
                                                         " → "
                                                         (symbol->string (los->symbol (third x)))))))
                                rules))
                     1)]
                   [renamed (if (equal? derv-type 'level-left)
                                (generate-levels-bfs-leftmost (yield (treelist (grammar-start cfg)) 0)
                                                              rules
                                                              (make-hash)
                                                              (foldr (lambda (val accum)
                                                                       (begin
                                                                         (hash-set! accum val 1)
                                                                         accum))
                                                                     (make-hash)
                                                                     (cfg-get-alphabet cfg)))
                                (generate-levels-bfs-rightmost (yield (treelist (grammar-start cfg))
                                                                      0)
                                                               rules
                                                               (make-hash)
                                                               (foldr (lambda (val accum)
                                                                        (begin
                                                                          (hash-set! accum val 1)
                                                                          accum))
                                                                      (make-hash)
                                                                      (cfg-get-alphabet cfg))))]
                   [w-der (convert-yield-deriv-to-word-deriv word derivation)]
                   [yield-trees (map create-yield-tree (map reverse (create-list-of-levels renamed)))]
                   [dgraph (dgrph renamed
                                  '()
                                  '()
                                  '()
                                  (append (rest rules) (list "" ""))
                                  (list (first rules))
                                  (reverse yield-trees)
                                  (list (tree (grammar-start cfg) '())))]
                   [lod (reverse (create-dgrphs dgraph '()))]
                   [invar-nodes
                    (map (lambda (a-dgrph)
                           (create-invariant-nodes a-dgrph invariants (grammar-start cfg) derv-type))
                         lod)]
                   [ordered-nodes (reverse (map (if (eq? derv-type 'level-left)
                                                    get-level-leftmost-order
                                                    get-level-rightmost-order)
                                                yield-trees))]
                   [broken-invariants (list->zipper (cons '()
                                                          (map (lambda (lst) (map undo-renaming lst))
                                                               (map reverse
                                                                    (rest (get-ordered-invariant-nodes
                                                                           ordered-nodes
                                                                           invar-nodes))))))]
                   [rank-node-lvls (cons (list (list 'S))
                                         (accumulate-previous-ranks
                                          (map (lambda (x) (map (lambda (y) (second y)) x)) renamed)
                                          (list (list 'S))))]
                   [graphs (map (lambda (dgrph node-lvls)
                                  (create-graph-structs dgrph
                                                        invariants
                                                        derv-type
                                                        (grammar-start cfg)
                                                        node-lvls))
                                lod
                                rank-node-lvls)])
              (init-viz cfg
                        word
                        w-der
                        string-rules
                        graphs
                        broken-invariants
                        #:special-graphs? 'cfg
                        #:rank-node-lst rank-node-lvls))))))

(define numb>numa (make-cfg '(S A)
                            '(a b)
                            `((S ,ARROW b)
                              (S ,ARROW AbA)
                              (A ,ARROW AaAbA)
                              (A ,ARROW AbAaA)
                              (A ,ARROW ,EMP)
                              (A ,ARROW bA))
                            'S))

(define buggy-numb>numa
  (make-cfg
   '(S A)
   '(a b)
   `((S ,ARROW b) (S ,ARROW AbA) (A ,ARROW AaAbA) (A ,ARROW AbAaA) (A ,ARROW a) (A ,ARROW bA))
   'S))

#;(grammar-derive buggy-numb>numa '(a b a))

(define palindrome
  (make-unchecked-cfg '(S A)
                      '(a b)
                      '((S -> ε) (S -> aSa) (S -> bSb) (S -> aAa) (S -> bAb) (A -> aS) (A -> bS))
                      'S))

;(cfg-viz palindrome '(a b a a b b a b a) 'left)

(define (A-INV w)
  (let ([as (filter (lambda (symb) (eq? symb 'a)) w)] [bs (filter (lambda (symb) (eq? symb 'b)) w)])
    (>= (length bs) (length as))))

(define (S-INV w)
  (let ([as (filter (lambda (symb) (eq? symb 'a)) w)] [bs (filter (lambda (symb) (eq? symb 'b)) w)])
    (> (length bs) (length as))))

(define test-cfg
  (make-cfg
   '(S A B)
   '(a b c d)
   `((S ,ARROW ,EMP) (S ,ARROW AB) (A ,ARROW aAb) (B ,ARROW cBd) (A ,ARROW ,EMP) (B ,ARROW ,EMP))
   'S))

(define testcfg
  (make-cfg
   '(S A B)
   '(a b c d)
   `((S ,ARROW ,EMP) (S ,ARROW AB) (A ,ARROW aSb) (B ,ARROW cBd) (A ,ARROW ,EMP) (B ,ARROW ,EMP))
   'S))

#;(cfg-viz testcfg '(a a b b c c c d d d) 'left)
#;
(time (cfg-derive-queue-and-hash testcfg
                                 '(a a a a a a a a b b b b b b b b b c c c c c c c c d d d d d d d d)
                                 'left))
#;(cfg-viz testcfg
           '(a a
               a
               a
               a
               a
               a
               a
               a
               a
               a
               a
               a
               a
               a
               a
               b
               b
               b
               b
               b
               b
               b
               b
               b
               b
               b
               b
               b
               b
               b
               b
               c
               c
               c
               c
               c
               c
               c
               c
               c
               c
               c
               c
               c
               c
               c
               c
               d
               d
               d
               d
               d
               d
               d
               d
               d
               d
               d
               d
               d
               d
               d
               d)
           'left
           (list 'S (lambda (x) #f))
           (list 'A (lambda (x) #f)))
;(grammar-derive numb>numa '(a b b a a b b a b b b))

#;(define G (make-cfg '(S) '(a b) `((S ,ARROW ,EMP) (S ,ARROW aS)) 'S))
;(cfg-derive-with-rule-application G '(a a a) 'left)
#;(cfg-viz G '(a a a) 'right)
